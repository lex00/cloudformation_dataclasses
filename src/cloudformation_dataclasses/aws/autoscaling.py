"""
AWS CloudFormation AutoScaling Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 21:37:31

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service AutoScaling
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class AcceleratorManufacturer:
    """AcceleratorManufacturer enum values."""

    NVIDIA = "nvidia"
    AMD = "amd"
    AMAZON_WEB_SERVICES = "amazon-web-services"
    XILINX = "xilinx"


class AcceleratorName:
    """AcceleratorName enum values."""

    A100 = "a100"
    V100 = "v100"
    K80 = "k80"
    T4 = "t4"
    M60 = "m60"
    RADEON_PRO_V520 = "radeon-pro-v520"
    VU9P = "vu9p"


class AcceleratorType:
    """AcceleratorType enum values."""

    GPU = "gpu"
    FPGA = "fpga"
    INFERENCE = "inference"


class BareMetal:
    """BareMetal enum values."""

    INCLUDED = "included"
    EXCLUDED = "excluded"
    REQUIRED = "required"


class BurstablePerformance:
    """BurstablePerformance enum values."""

    INCLUDED = "included"
    EXCLUDED = "excluded"
    REQUIRED = "required"


class CapacityDistributionStrategy:
    """CapacityDistributionStrategy enum values."""

    BALANCED_ONLY = "balanced-only"
    BALANCED_BEST_EFFORT = "balanced-best-effort"


class CapacityReservationPreference:
    """CapacityReservationPreference enum values."""

    CAPACITY_RESERVATIONS_ONLY = "capacity-reservations-only"
    CAPACITY_RESERVATIONS_FIRST = "capacity-reservations-first"
    NONE = "none"
    DEFAULT = "default"


class CpuManufacturer:
    """CpuManufacturer enum values."""

    INTEL = "intel"
    AMD = "amd"
    AMAZON_WEB_SERVICES = "amazon-web-services"
    APPLE = "apple"


class ImpairedZoneHealthCheckBehavior:
    """ImpairedZoneHealthCheckBehavior enum values."""

    REPLACEUNHEALTHY = "ReplaceUnhealthy"
    IGNOREUNHEALTHY = "IgnoreUnhealthy"


class InstanceGeneration:
    """InstanceGeneration enum values."""

    CURRENT = "current"
    PREVIOUS = "previous"


class InstanceMetadataEndpointState:
    """InstanceMetadataEndpointState enum values."""

    DISABLED = "disabled"
    ENABLED = "enabled"


class InstanceMetadataHttpTokensState:
    """InstanceMetadataHttpTokensState enum values."""

    OPTIONAL = "optional"
    REQUIRED = "required"


class InstanceRefreshStatus:
    """InstanceRefreshStatus enum values."""

    PENDING = "Pending"
    INPROGRESS = "InProgress"
    SUCCESSFUL = "Successful"
    FAILED = "Failed"
    CANCELLING = "Cancelling"
    CANCELLED = "Cancelled"
    ROLLBACKINPROGRESS = "RollbackInProgress"
    ROLLBACKFAILED = "RollbackFailed"
    ROLLBACKSUCCESSFUL = "RollbackSuccessful"
    BAKING = "Baking"


class LifecycleState:
    """LifecycleState enum values."""

    PENDING = "Pending"
    PENDING_WAIT = "Pending:Wait"
    PENDING_PROCEED = "Pending:Proceed"
    QUARANTINED = "Quarantined"
    INSERVICE = "InService"
    TERMINATING = "Terminating"
    TERMINATING_WAIT = "Terminating:Wait"
    TERMINATING_PROCEED = "Terminating:Proceed"
    TERMINATED = "Terminated"
    DETACHING = "Detaching"
    DETACHED = "Detached"
    ENTERINGSTANDBY = "EnteringStandby"
    STANDBY = "Standby"
    WARMED_PENDING = "Warmed:Pending"
    WARMED_PENDING_WAIT = "Warmed:Pending:Wait"
    WARMED_PENDING_PROCEED = "Warmed:Pending:Proceed"
    WARMED_TERMINATING = "Warmed:Terminating"
    WARMED_TERMINATING_WAIT = "Warmed:Terminating:Wait"
    WARMED_TERMINATING_PROCEED = "Warmed:Terminating:Proceed"
    WARMED_TERMINATED = "Warmed:Terminated"
    WARMED_STOPPED = "Warmed:Stopped"
    WARMED_RUNNING = "Warmed:Running"
    WARMED_HIBERNATED = "Warmed:Hibernated"


class LocalStorage:
    """LocalStorage enum values."""

    INCLUDED = "included"
    EXCLUDED = "excluded"
    REQUIRED = "required"


class LocalStorageType:
    """LocalStorageType enum values."""

    HDD = "hdd"
    SSD = "ssd"


class MetricStatistic:
    """MetricStatistic enum values."""

    AVERAGE = "Average"
    MINIMUM = "Minimum"
    MAXIMUM = "Maximum"
    SAMPLECOUNT = "SampleCount"
    SUM = "Sum"


class MetricType:
    """MetricType enum values."""

    ASGAVERAGECPUUTILIZATION = "ASGAverageCPUUtilization"
    ASGAVERAGENETWORKIN = "ASGAverageNetworkIn"
    ASGAVERAGENETWORKOUT = "ASGAverageNetworkOut"
    ALBREQUESTCOUNTPERTARGET = "ALBRequestCountPerTarget"


class PredefinedLoadMetricType:
    """PredefinedLoadMetricType enum values."""

    ASGTOTALCPUUTILIZATION = "ASGTotalCPUUtilization"
    ASGTOTALNETWORKIN = "ASGTotalNetworkIn"
    ASGTOTALNETWORKOUT = "ASGTotalNetworkOut"
    ALBTARGETGROUPREQUESTCOUNT = "ALBTargetGroupRequestCount"


class PredefinedMetricPairType:
    """PredefinedMetricPairType enum values."""

    ASGCPUUTILIZATION = "ASGCPUUtilization"
    ASGNETWORKIN = "ASGNetworkIn"
    ASGNETWORKOUT = "ASGNetworkOut"
    ALBREQUESTCOUNT = "ALBRequestCount"


class PredefinedScalingMetricType:
    """PredefinedScalingMetricType enum values."""

    ASGAVERAGECPUUTILIZATION = "ASGAverageCPUUtilization"
    ASGAVERAGENETWORKIN = "ASGAverageNetworkIn"
    ASGAVERAGENETWORKOUT = "ASGAverageNetworkOut"
    ALBREQUESTCOUNTPERTARGET = "ALBRequestCountPerTarget"


class PredictiveScalingMaxCapacityBreachBehavior:
    """PredictiveScalingMaxCapacityBreachBehavior enum values."""

    HONORMAXCAPACITY = "HonorMaxCapacity"
    INCREASEMAXCAPACITY = "IncreaseMaxCapacity"


class PredictiveScalingMode:
    """PredictiveScalingMode enum values."""

    FORECASTANDSCALE = "ForecastAndScale"
    FORECASTONLY = "ForecastOnly"


class RefreshStrategy:
    """RefreshStrategy enum values."""

    ROLLING = "Rolling"
    REPLACEROOTVOLUME = "ReplaceRootVolume"


class RetentionAction:
    """RetentionAction enum values."""

    RETAIN = "retain"
    TERMINATE = "terminate"


class RetryStrategy:
    """RetryStrategy enum values."""

    RETRY_WITH_GROUP_CONFIGURATION = "retry-with-group-configuration"
    NONE = "none"


class ScaleInProtectedInstances:
    """ScaleInProtectedInstances enum values."""

    REFRESH = "Refresh"
    IGNORE = "Ignore"
    WAIT = "Wait"


class ScalingActivityStatusCode:
    """ScalingActivityStatusCode enum values."""

    PENDINGSPOTBIDPLACEMENT = "PendingSpotBidPlacement"
    WAITINGFORSPOTINSTANCEREQUESTID = "WaitingForSpotInstanceRequestId"
    WAITINGFORSPOTINSTANCEID = "WaitingForSpotInstanceId"
    WAITINGFORINSTANCEID = "WaitingForInstanceId"
    PREINSERVICE = "PreInService"
    INPROGRESS = "InProgress"
    WAITINGFORELBCONNECTIONDRAINING = "WaitingForELBConnectionDraining"
    MIDLIFECYCLEACTION = "MidLifecycleAction"
    WAITINGFORINSTANCEWARMUP = "WaitingForInstanceWarmup"
    SUCCESSFUL = "Successful"
    FAILED = "Failed"
    CANCELLED = "Cancelled"
    WAITINGFORCONNECTIONDRAINING = "WaitingForConnectionDraining"
    WAITINGFORINPLACEUPDATETOSTART = "WaitingForInPlaceUpdateToStart"
    WAITINGFORINPLACEUPDATETOFINALIZE = "WaitingForInPlaceUpdateToFinalize"
    INPLACEUPDATEINPROGRESS = "InPlaceUpdateInProgress"


class StandbyInstances:
    """StandbyInstances enum values."""

    TERMINATE = "Terminate"
    IGNORE = "Ignore"
    WAIT = "Wait"


class WarmPoolState:
    """WarmPoolState enum values."""

    STOPPED = "Stopped"
    RUNNING = "Running"
    HIBERNATED = "Hibernated"


class WarmPoolStatus:
    """WarmPoolStatus enum values."""

    PENDINGDELETE = "PendingDelete"


# Convenient aliases for enum values
NVIDIA = AcceleratorManufacturer.NVIDIA
AMD = AcceleratorManufacturer.AMD
AMAZON_WEB_SERVICES = AcceleratorManufacturer.AMAZON_WEB_SERVICES
XILINX = AcceleratorManufacturer.XILINX
A100 = AcceleratorName.A100
V100 = AcceleratorName.V100
K80 = AcceleratorName.K80
T4 = AcceleratorName.T4
M60 = AcceleratorName.M60
RADEON_PRO_V520 = AcceleratorName.RADEON_PRO_V520
VU9P = AcceleratorName.VU9P
GPU = AcceleratorType.GPU
FPGA = AcceleratorType.FPGA
INFERENCE = AcceleratorType.INFERENCE
INCLUDED = BareMetal.INCLUDED
EXCLUDED = BareMetal.EXCLUDED
REQUIRED = BareMetal.REQUIRED
INCLUDED = BurstablePerformance.INCLUDED
EXCLUDED = BurstablePerformance.EXCLUDED
REQUIRED = BurstablePerformance.REQUIRED
BALANCED_ONLY = CapacityDistributionStrategy.BALANCED_ONLY
BALANCED_BEST_EFFORT = CapacityDistributionStrategy.BALANCED_BEST_EFFORT
CAPACITY_RESERVATIONS_ONLY = CapacityReservationPreference.CAPACITY_RESERVATIONS_ONLY
CAPACITY_RESERVATIONS_FIRST = CapacityReservationPreference.CAPACITY_RESERVATIONS_FIRST
NONE = CapacityReservationPreference.NONE
DEFAULT = CapacityReservationPreference.DEFAULT
INTEL = CpuManufacturer.INTEL
AMD = CpuManufacturer.AMD
AMAZON_WEB_SERVICES = CpuManufacturer.AMAZON_WEB_SERVICES
APPLE = CpuManufacturer.APPLE
REPLACEUNHEALTHY = ImpairedZoneHealthCheckBehavior.REPLACEUNHEALTHY
IGNOREUNHEALTHY = ImpairedZoneHealthCheckBehavior.IGNOREUNHEALTHY
CURRENT = InstanceGeneration.CURRENT
PREVIOUS = InstanceGeneration.PREVIOUS
DISABLED = InstanceMetadataEndpointState.DISABLED
ENABLED = InstanceMetadataEndpointState.ENABLED
OPTIONAL = InstanceMetadataHttpTokensState.OPTIONAL
REQUIRED = InstanceMetadataHttpTokensState.REQUIRED
PENDING = InstanceRefreshStatus.PENDING
INPROGRESS = InstanceRefreshStatus.INPROGRESS
SUCCESSFUL = InstanceRefreshStatus.SUCCESSFUL
FAILED = InstanceRefreshStatus.FAILED
CANCELLING = InstanceRefreshStatus.CANCELLING
CANCELLED = InstanceRefreshStatus.CANCELLED
ROLLBACKINPROGRESS = InstanceRefreshStatus.ROLLBACKINPROGRESS
ROLLBACKFAILED = InstanceRefreshStatus.ROLLBACKFAILED
ROLLBACKSUCCESSFUL = InstanceRefreshStatus.ROLLBACKSUCCESSFUL
BAKING = InstanceRefreshStatus.BAKING
PENDING = LifecycleState.PENDING
PENDING_WAIT = LifecycleState.PENDING_WAIT
PENDING_PROCEED = LifecycleState.PENDING_PROCEED
QUARANTINED = LifecycleState.QUARANTINED
INSERVICE = LifecycleState.INSERVICE
TERMINATING = LifecycleState.TERMINATING
TERMINATING_WAIT = LifecycleState.TERMINATING_WAIT
TERMINATING_PROCEED = LifecycleState.TERMINATING_PROCEED
TERMINATED = LifecycleState.TERMINATED
DETACHING = LifecycleState.DETACHING
DETACHED = LifecycleState.DETACHED
ENTERINGSTANDBY = LifecycleState.ENTERINGSTANDBY
STANDBY = LifecycleState.STANDBY
WARMED_PENDING = LifecycleState.WARMED_PENDING
WARMED_PENDING_WAIT = LifecycleState.WARMED_PENDING_WAIT
WARMED_PENDING_PROCEED = LifecycleState.WARMED_PENDING_PROCEED
WARMED_TERMINATING = LifecycleState.WARMED_TERMINATING
WARMED_TERMINATING_WAIT = LifecycleState.WARMED_TERMINATING_WAIT
WARMED_TERMINATING_PROCEED = LifecycleState.WARMED_TERMINATING_PROCEED
WARMED_TERMINATED = LifecycleState.WARMED_TERMINATED
WARMED_STOPPED = LifecycleState.WARMED_STOPPED
WARMED_RUNNING = LifecycleState.WARMED_RUNNING
WARMED_HIBERNATED = LifecycleState.WARMED_HIBERNATED
INCLUDED = LocalStorage.INCLUDED
EXCLUDED = LocalStorage.EXCLUDED
REQUIRED = LocalStorage.REQUIRED
HDD = LocalStorageType.HDD
SSD = LocalStorageType.SSD
AVERAGE = MetricStatistic.AVERAGE
MINIMUM = MetricStatistic.MINIMUM
MAXIMUM = MetricStatistic.MAXIMUM
SAMPLECOUNT = MetricStatistic.SAMPLECOUNT
SUM = MetricStatistic.SUM
ASGAVERAGECPUUTILIZATION = MetricType.ASGAVERAGECPUUTILIZATION
ASGAVERAGENETWORKIN = MetricType.ASGAVERAGENETWORKIN
ASGAVERAGENETWORKOUT = MetricType.ASGAVERAGENETWORKOUT
ALBREQUESTCOUNTPERTARGET = MetricType.ALBREQUESTCOUNTPERTARGET
ASGTOTALCPUUTILIZATION = PredefinedLoadMetricType.ASGTOTALCPUUTILIZATION
ASGTOTALNETWORKIN = PredefinedLoadMetricType.ASGTOTALNETWORKIN
ASGTOTALNETWORKOUT = PredefinedLoadMetricType.ASGTOTALNETWORKOUT
ALBTARGETGROUPREQUESTCOUNT = PredefinedLoadMetricType.ALBTARGETGROUPREQUESTCOUNT
ASGCPUUTILIZATION = PredefinedMetricPairType.ASGCPUUTILIZATION
ASGNETWORKIN = PredefinedMetricPairType.ASGNETWORKIN
ASGNETWORKOUT = PredefinedMetricPairType.ASGNETWORKOUT
ALBREQUESTCOUNT = PredefinedMetricPairType.ALBREQUESTCOUNT
ASGAVERAGECPUUTILIZATION = PredefinedScalingMetricType.ASGAVERAGECPUUTILIZATION
ASGAVERAGENETWORKIN = PredefinedScalingMetricType.ASGAVERAGENETWORKIN
ASGAVERAGENETWORKOUT = PredefinedScalingMetricType.ASGAVERAGENETWORKOUT
ALBREQUESTCOUNTPERTARGET = PredefinedScalingMetricType.ALBREQUESTCOUNTPERTARGET
HONORMAXCAPACITY = PredictiveScalingMaxCapacityBreachBehavior.HONORMAXCAPACITY
INCREASEMAXCAPACITY = PredictiveScalingMaxCapacityBreachBehavior.INCREASEMAXCAPACITY
FORECASTANDSCALE = PredictiveScalingMode.FORECASTANDSCALE
FORECASTONLY = PredictiveScalingMode.FORECASTONLY
ROLLING = RefreshStrategy.ROLLING
REPLACEROOTVOLUME = RefreshStrategy.REPLACEROOTVOLUME
RETAIN = RetentionAction.RETAIN
TERMINATE = RetentionAction.TERMINATE
RETRY_WITH_GROUP_CONFIGURATION = RetryStrategy.RETRY_WITH_GROUP_CONFIGURATION
NONE = RetryStrategy.NONE
REFRESH = ScaleInProtectedInstances.REFRESH
IGNORE = ScaleInProtectedInstances.IGNORE
WAIT = ScaleInProtectedInstances.WAIT
PENDINGSPOTBIDPLACEMENT = ScalingActivityStatusCode.PENDINGSPOTBIDPLACEMENT
WAITINGFORSPOTINSTANCEREQUESTID = ScalingActivityStatusCode.WAITINGFORSPOTINSTANCEREQUESTID
WAITINGFORSPOTINSTANCEID = ScalingActivityStatusCode.WAITINGFORSPOTINSTANCEID
WAITINGFORINSTANCEID = ScalingActivityStatusCode.WAITINGFORINSTANCEID
PREINSERVICE = ScalingActivityStatusCode.PREINSERVICE
INPROGRESS = ScalingActivityStatusCode.INPROGRESS
WAITINGFORELBCONNECTIONDRAINING = ScalingActivityStatusCode.WAITINGFORELBCONNECTIONDRAINING
MIDLIFECYCLEACTION = ScalingActivityStatusCode.MIDLIFECYCLEACTION
WAITINGFORINSTANCEWARMUP = ScalingActivityStatusCode.WAITINGFORINSTANCEWARMUP
SUCCESSFUL = ScalingActivityStatusCode.SUCCESSFUL
FAILED = ScalingActivityStatusCode.FAILED
CANCELLED = ScalingActivityStatusCode.CANCELLED
WAITINGFORCONNECTIONDRAINING = ScalingActivityStatusCode.WAITINGFORCONNECTIONDRAINING
WAITINGFORINPLACEUPDATETOSTART = ScalingActivityStatusCode.WAITINGFORINPLACEUPDATETOSTART
WAITINGFORINPLACEUPDATETOFINALIZE = ScalingActivityStatusCode.WAITINGFORINPLACEUPDATETOFINALIZE
INPLACEUPDATEINPROGRESS = ScalingActivityStatusCode.INPLACEUPDATEINPROGRESS
TERMINATE = StandbyInstances.TERMINATE
IGNORE = StandbyInstances.IGNORE
WAIT = StandbyInstances.WAIT
STOPPED = WarmPoolState.STOPPED
RUNNING = WarmPoolState.RUNNING
HIBERNATED = WarmPoolState.HIBERNATED
PENDINGDELETE = WarmPoolStatus.PENDINGDELETE


@dataclass
class AcceleratorCountRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "min": "Min",
        "max": "Max",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class AcceleratorTotalMemoryMiBRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "min": "Min",
        "max": "Max",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class AvailabilityZoneDistribution:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "capacity_distribution_strategy": "CapacityDistributionStrategy",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_distribution_strategy: Optional[Union[str, CapacityDistributionStrategy, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class AvailabilityZoneImpairmentPolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "zonal_shift_enabled": "ZonalShiftEnabled",
        "impaired_zone_health_check_behavior": "ImpairedZoneHealthCheckBehavior",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    zonal_shift_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    impaired_zone_health_check_behavior: Optional[Union[str, ImpairedZoneHealthCheckBehavior, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class BaselineEbsBandwidthMbpsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "min": "Min",
        "max": "Max",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class BaselinePerformanceFactorsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "cpu": "Cpu",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu: Optional[CpuPerformanceFactorRequest] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class CapacityReservationSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "capacity_reservation_preference": "CapacityReservationPreference",
        "capacity_reservation_target": "CapacityReservationTarget",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_reservation_preference: Optional[Union[str, CapacityReservationPreference, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_reservation_target: Optional[CapacityReservationTarget] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class CapacityReservationTarget:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "capacity_reservation_ids": "CapacityReservationIds",
        "capacity_reservation_resource_group_arns": "CapacityReservationResourceGroupArns",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_reservation_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_reservation_resource_group_arns: Optional[Union[list[str], Ref]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class CpuPerformanceFactorRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "references": "References",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    references: Optional[list[PerformanceFactorReferenceRequest]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class InstanceMaintenancePolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "max_healthy_percentage": "MaxHealthyPercentage",
        "min_healthy_percentage": "MinHealthyPercentage",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_healthy_percentage: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min_healthy_percentage: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class InstanceRequirements:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "instance_generations": "InstanceGenerations",
        "accelerator_types": "AcceleratorTypes",
        "memory_gi_b_per_v_cpu": "MemoryGiBPerVCpu",
        "accelerator_manufacturers": "AcceleratorManufacturers",
        "v_cpu_count": "VCpuCount",
        "local_storage": "LocalStorage",
        "cpu_manufacturers": "CpuManufacturers",
        "bare_metal": "BareMetal",
        "require_hibernate_support": "RequireHibernateSupport",
        "max_spot_price_as_percentage_of_optimal_on_demand_price": "MaxSpotPriceAsPercentageOfOptimalOnDemandPrice",
        "on_demand_max_price_percentage_over_lowest_price": "OnDemandMaxPricePercentageOverLowestPrice",
        "memory_mi_b": "MemoryMiB",
        "local_storage_types": "LocalStorageTypes",
        "network_interface_count": "NetworkInterfaceCount",
        "excluded_instance_types": "ExcludedInstanceTypes",
        "allowed_instance_types": "AllowedInstanceTypes",
        "accelerator_count": "AcceleratorCount",
        "network_bandwidth_gbps": "NetworkBandwidthGbps",
        "baseline_performance_factors": "BaselinePerformanceFactors",
        "baseline_ebs_bandwidth_mbps": "BaselineEbsBandwidthMbps",
        "spot_max_price_percentage_over_lowest_price": "SpotMaxPricePercentageOverLowestPrice",
        "accelerator_names": "AcceleratorNames",
        "accelerator_total_memory_mi_b": "AcceleratorTotalMemoryMiB",
        "burstable_performance": "BurstablePerformance",
        "total_local_storage_gb": "TotalLocalStorageGB",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_generations: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    memory_gi_b_per_v_cpu: Optional[MemoryGiBPerVCpuRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_manufacturers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    v_cpu_count: Optional[VCpuCountRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_storage: Optional[Union[str, LocalStorage, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu_manufacturers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bare_metal: Optional[Union[str, BareMetal, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    require_hibernate_support: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_spot_price_as_percentage_of_optimal_on_demand_price: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_demand_max_price_percentage_over_lowest_price: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    memory_mi_b: Optional[MemoryMiBRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_storage_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_interface_count: Optional[NetworkInterfaceCountRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    excluded_instance_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allowed_instance_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_count: Optional[AcceleratorCountRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_bandwidth_gbps: Optional[NetworkBandwidthGbpsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    baseline_performance_factors: Optional[BaselinePerformanceFactorsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    baseline_ebs_bandwidth_mbps: Optional[BaselineEbsBandwidthMbpsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_max_price_percentage_over_lowest_price: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_names: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_total_memory_mi_b: Optional[AcceleratorTotalMemoryMiBRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    burstable_performance: Optional[Union[str, BurstablePerformance, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    total_local_storage_gb: Optional[TotalLocalStorageGBRequest] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class InstancesDistribution:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "on_demand_allocation_strategy": "OnDemandAllocationStrategy",
        "on_demand_base_capacity": "OnDemandBaseCapacity",
        "on_demand_percentage_above_base_capacity": "OnDemandPercentageAboveBaseCapacity",
        "spot_instance_pools": "SpotInstancePools",
        "spot_allocation_strategy": "SpotAllocationStrategy",
        "spot_max_price": "SpotMaxPrice",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_demand_allocation_strategy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_demand_base_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_demand_percentage_above_base_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_instance_pools: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_allocation_strategy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_max_price: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class LaunchTemplate:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "launch_template_specification": "LaunchTemplateSpecification",
        "overrides": "Overrides",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_specification: Optional[LaunchTemplateSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    overrides: Optional[list[LaunchTemplateOverrides]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class LaunchTemplateOverrides:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "launch_template_specification": "LaunchTemplateSpecification",
        "weighted_capacity": "WeightedCapacity",
        "instance_requirements": "InstanceRequirements",
        "instance_type": "InstanceType",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_specification: Optional[LaunchTemplateSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    weighted_capacity: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_requirements: Optional[InstanceRequirements] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class LaunchTemplateSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "launch_template_name": "LaunchTemplateName",
        "version": "Version",
        "launch_template_id": "LaunchTemplateId",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class LifecycleHookSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "lifecycle_hook_name": "LifecycleHookName",
        "lifecycle_transition": "LifecycleTransition",
        "heartbeat_timeout": "HeartbeatTimeout",
        "notification_metadata": "NotificationMetadata",
        "default_result": "DefaultResult",
        "notification_target_arn": "NotificationTargetARN",
        "role_arn": "RoleARN",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lifecycle_hook_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lifecycle_transition: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    heartbeat_timeout: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    notification_metadata: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_result: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    notification_target_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class MemoryGiBPerVCpuRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "min": "Min",
        "max": "Max",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class MemoryMiBRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "min": "Min",
        "max": "Max",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class MetricsCollection:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "metrics": "Metrics",
        "granularity": "Granularity",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metrics: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    granularity: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class MixedInstancesPolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "instances_distribution": "InstancesDistribution",
        "launch_template": "LaunchTemplate",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instances_distribution: Optional[InstancesDistribution] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template: Optional[LaunchTemplate] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class NetworkBandwidthGbpsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "min": "Min",
        "max": "Max",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class NetworkInterfaceCountRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "min": "Min",
        "max": "Max",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class NotificationConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "topic_arn": "TopicARN",
        "notification_types": "NotificationTypes",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    topic_arn: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    notification_types: Optional[Union[list[str], Ref]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class PerformanceFactorReferenceRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "instance_family": "InstanceFamily",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_family: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TagProperty:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "value": "Value",
        "key": "Key",
        "propagate_at_launch": "PropagateAtLaunch",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    propagate_at_launch: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TotalLocalStorageGBRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "min": "Min",
        "max": "Max",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TrafficSourceIdentifier:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "type_": "Type",
        "identifier": "Identifier",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    identifier: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class VCpuCountRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "min": "Min",
        "max": "Max",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class AutoScalingGroup(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-autos"""

    resource_type: ClassVar[str] = "AWS::AutoScaling::AutoScalingGroup"
    _property_mappings: ClassVar[dict[str, str]] = {
        "lifecycle_hook_specification_list": "LifecycleHookSpecificationList",
        "load_balancer_names": "LoadBalancerNames",
        "launch_configuration_name": "LaunchConfigurationName",
        "service_linked_role_arn": "ServiceLinkedRoleARN",
        "availability_zone_impairment_policy": "AvailabilityZoneImpairmentPolicy",
        "target_group_ar_ns": "TargetGroupARNs",
        "cooldown": "Cooldown",
        "notification_configurations": "NotificationConfigurations",
        "desired_capacity": "DesiredCapacity",
        "health_check_grace_period": "HealthCheckGracePeriod",
        "default_instance_warmup": "DefaultInstanceWarmup",
        "skip_zonal_shift_validation": "SkipZonalShiftValidation",
        "new_instances_protected_from_scale_in": "NewInstancesProtectedFromScaleIn",
        "launch_template": "LaunchTemplate",
        "mixed_instances_policy": "MixedInstancesPolicy",
        "vpc_zone_identifier": "VPCZoneIdentifier",
        "tags": "Tags",
        "context": "Context",
        "capacity_rebalance": "CapacityRebalance",
        "instance_id": "InstanceId",
        "availability_zones": "AvailabilityZones",
        "availability_zone_distribution": "AvailabilityZoneDistribution",
        "metrics_collection": "MetricsCollection",
        "instance_maintenance_policy": "InstanceMaintenancePolicy",
        "max_size": "MaxSize",
        "min_size": "MinSize",
        "termination_policies": "TerminationPolicies",
        "auto_scaling_group_name": "AutoScalingGroupName",
        "traffic_sources": "TrafficSources",
        "desired_capacity_type": "DesiredCapacityType",
        "placement_group": "PlacementGroup",
        "capacity_reservation_specification": "CapacityReservationSpecification",
        "health_check_type": "HealthCheckType",
        "max_instance_lifetime": "MaxInstanceLifetime",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    lifecycle_hook_specification_list: Optional[list[LifecycleHookSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    load_balancer_names: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    launch_configuration_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    service_linked_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zone_impairment_policy: Optional[AvailabilityZoneImpairmentPolicy] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    target_group_ar_ns: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cooldown: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    notification_configurations: Optional[list[NotificationConfiguration]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    desired_capacity: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    health_check_grace_period: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    default_instance_warmup: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    skip_zonal_shift_validation: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    new_instances_protected_from_scale_in: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    launch_template: Optional[LaunchTemplateSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    mixed_instances_policy: Optional[MixedInstancesPolicy] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_zone_identifier: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[TagProperty]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    context: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    capacity_rebalance: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zones: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zone_distribution: Optional[AvailabilityZoneDistribution] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    metrics_collection: Optional[list[MetricsCollection]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_maintenance_policy: Optional[InstanceMaintenancePolicy] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_size: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    min_size: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    termination_policies: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auto_scaling_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    traffic_sources: Optional[list[TrafficSourceIdentifier]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    desired_capacity_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    placement_group: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    capacity_reservation_specification: Optional[CapacityReservationSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    health_check_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_instance_lifetime: Optional[Union[int, Ref, GetAtt, Sub]] = None

    @property
    def attr_auto_scaling_group_arn(self) -> GetAtt:
        """Get the AutoScalingGroupARN attribute."""
        return self.get_att("AutoScalingGroupARN")




@dataclass
class BlockDevice:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "snapshot_id": "SnapshotId",
        "volume_type": "VolumeType",
        "encrypted": "Encrypted",
        "throughput": "Throughput",
        "iops": "Iops",
        "volume_size": "VolumeSize",
        "delete_on_termination": "DeleteOnTermination",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    snapshot_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    encrypted: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    throughput: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    iops: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    delete_on_termination: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class BlockDeviceMapping:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "ebs": "Ebs",
        "no_device": "NoDevice",
        "virtual_name": "VirtualName",
        "device_name": "DeviceName",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ebs: Optional[BlockDevice] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    no_device: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    virtual_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    device_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class MetadataOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "http_put_response_hop_limit": "HttpPutResponseHopLimit",
        "http_tokens": "HttpTokens",
        "http_endpoint": "HttpEndpoint",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    http_put_response_hop_limit: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    http_tokens: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    http_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class LaunchConfiguration(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-autos"""

    resource_type: ClassVar[str] = "AWS::AutoScaling::LaunchConfiguration"
    _property_mappings: ClassVar[dict[str, str]] = {
        "placement_tenancy": "PlacementTenancy",
        "security_groups": "SecurityGroups",
        "launch_configuration_name": "LaunchConfigurationName",
        "metadata_options": "MetadataOptions",
        "instance_id": "InstanceId",
        "user_data": "UserData",
        "classic_link_vpc_security_groups": "ClassicLinkVPCSecurityGroups",
        "block_device_mappings": "BlockDeviceMappings",
        "iam_instance_profile": "IamInstanceProfile",
        "kernel_id": "KernelId",
        "associate_public_ip_address": "AssociatePublicIpAddress",
        "classic_link_vpc_id": "ClassicLinkVPCId",
        "ebs_optimized": "EbsOptimized",
        "key_name": "KeyName",
        "spot_price": "SpotPrice",
        "image_id": "ImageId",
        "instance_type": "InstanceType",
        "ram_disk_id": "RamDiskId",
        "instance_monitoring": "InstanceMonitoring",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    placement_tenancy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    security_groups: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    launch_configuration_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    metadata_options: Optional[MetadataOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    user_data: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    classic_link_vpc_security_groups: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    block_device_mappings: Optional[list[BlockDeviceMapping]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    iam_instance_profile: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kernel_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    associate_public_ip_address: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    classic_link_vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ebs_optimized: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    key_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    spot_price: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    image_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ram_disk_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_monitoring: Optional[Union[bool, Ref, GetAtt, Sub]] = None



@dataclass
class LifecycleHook(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-autos"""

    resource_type: ClassVar[str] = "AWS::AutoScaling::LifecycleHook"
    _property_mappings: ClassVar[dict[str, str]] = {
        "lifecycle_hook_name": "LifecycleHookName",
        "lifecycle_transition": "LifecycleTransition",
        "auto_scaling_group_name": "AutoScalingGroupName",
        "heartbeat_timeout": "HeartbeatTimeout",
        "notification_metadata": "NotificationMetadata",
        "default_result": "DefaultResult",
        "notification_target_arn": "NotificationTargetARN",
        "role_arn": "RoleARN",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    lifecycle_hook_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    lifecycle_transition: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auto_scaling_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    heartbeat_timeout: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    notification_metadata: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    default_result: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    notification_target_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None



@dataclass
class CustomizedMetricSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "metric_name": "MetricName",
        "metrics": "Metrics",
        "statistic": "Statistic",
        "dimensions": "Dimensions",
        "period": "Period",
        "unit": "Unit",
        "namespace": "Namespace",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metrics: Optional[list[TargetTrackingMetricDataQuery]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    statistic: Optional[Union[str, MetricStatistic, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dimensions: Optional[list[MetricDimension]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    period: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    unit: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    namespace: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class Metric:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "metric_name": "MetricName",
        "dimensions": "Dimensions",
        "namespace": "Namespace",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dimensions: Optional[list[MetricDimension]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    namespace: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class MetricDataQuery:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "return_data": "ReturnData",
        "expression": "Expression",
        "label": "Label",
        "metric_stat": "MetricStat",
        "id": "Id",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    return_data: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    expression: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    label: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_stat: Optional[MetricStat] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class MetricDimension:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "value": "Value",
        "name": "Name",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class MetricStat:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "stat": "Stat",
        "metric": "Metric",
        "unit": "Unit",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    stat: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric: Optional[Metric] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    unit: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class PredefinedMetricSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "predefined_metric_type": "PredefinedMetricType",
        "resource_label": "ResourceLabel",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    predefined_metric_type: Optional[Union[str, MetricType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_label: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class PredictiveScalingConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "max_capacity_breach_behavior": "MaxCapacityBreachBehavior",
        "max_capacity_buffer": "MaxCapacityBuffer",
        "mode": "Mode",
        "metric_specifications": "MetricSpecifications",
        "scheduling_buffer_time": "SchedulingBufferTime",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_capacity_breach_behavior: Optional[Union[str, PredictiveScalingMaxCapacityBreachBehavior, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_capacity_buffer: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mode: Optional[Union[str, PredictiveScalingMode, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_specifications: Optional[list[PredictiveScalingMetricSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scheduling_buffer_time: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class PredictiveScalingCustomizedCapacityMetric:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "metric_data_queries": "MetricDataQueries",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_data_queries: Optional[list[MetricDataQuery]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class PredictiveScalingCustomizedLoadMetric:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "metric_data_queries": "MetricDataQueries",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_data_queries: Optional[list[MetricDataQuery]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class PredictiveScalingCustomizedScalingMetric:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "metric_data_queries": "MetricDataQueries",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_data_queries: Optional[list[MetricDataQuery]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class PredictiveScalingMetricSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "customized_load_metric_specification": "CustomizedLoadMetricSpecification",
        "predefined_load_metric_specification": "PredefinedLoadMetricSpecification",
        "target_value": "TargetValue",
        "predefined_scaling_metric_specification": "PredefinedScalingMetricSpecification",
        "customized_capacity_metric_specification": "CustomizedCapacityMetricSpecification",
        "customized_scaling_metric_specification": "CustomizedScalingMetricSpecification",
        "predefined_metric_pair_specification": "PredefinedMetricPairSpecification",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    customized_load_metric_specification: Optional[PredictiveScalingCustomizedLoadMetric] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    predefined_load_metric_specification: Optional[PredictiveScalingPredefinedLoadMetric] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_value: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    predefined_scaling_metric_specification: Optional[PredictiveScalingPredefinedScalingMetric] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    customized_capacity_metric_specification: Optional[PredictiveScalingCustomizedCapacityMetric] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    customized_scaling_metric_specification: Optional[PredictiveScalingCustomizedScalingMetric] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    predefined_metric_pair_specification: Optional[PredictiveScalingPredefinedMetricPair] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class PredictiveScalingPredefinedLoadMetric:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "predefined_metric_type": "PredefinedMetricType",
        "resource_label": "ResourceLabel",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    predefined_metric_type: Optional[Union[str, PredefinedLoadMetricType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_label: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class PredictiveScalingPredefinedMetricPair:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "predefined_metric_type": "PredefinedMetricType",
        "resource_label": "ResourceLabel",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    predefined_metric_type: Optional[Union[str, PredefinedMetricPairType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_label: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class PredictiveScalingPredefinedScalingMetric:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "predefined_metric_type": "PredefinedMetricType",
        "resource_label": "ResourceLabel",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    predefined_metric_type: Optional[Union[str, PredefinedScalingMetricType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_label: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class StepAdjustment:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "metric_interval_upper_bound": "MetricIntervalUpperBound",
        "metric_interval_lower_bound": "MetricIntervalLowerBound",
        "scaling_adjustment": "ScalingAdjustment",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_interval_upper_bound: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_interval_lower_bound: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scaling_adjustment: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TargetTrackingConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "target_value": "TargetValue",
        "customized_metric_specification": "CustomizedMetricSpecification",
        "disable_scale_in": "DisableScaleIn",
        "predefined_metric_specification": "PredefinedMetricSpecification",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_value: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    customized_metric_specification: Optional[CustomizedMetricSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    disable_scale_in: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    predefined_metric_specification: Optional[PredefinedMetricSpecification] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TargetTrackingMetricDataQuery:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "return_data": "ReturnData",
        "expression": "Expression",
        "label": "Label",
        "metric_stat": "MetricStat",
        "period": "Period",
        "id": "Id",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    return_data: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    expression: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    label: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_stat: Optional[TargetTrackingMetricStat] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    period: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TargetTrackingMetricStat:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "stat": "Stat",
        "period": "Period",
        "metric": "Metric",
        "unit": "Unit",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    stat: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    period: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric: Optional[Metric] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    unit: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class ScalingPolicy(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-autos"""

    resource_type: ClassVar[str] = "AWS::AutoScaling::ScalingPolicy"
    _property_mappings: ClassVar[dict[str, str]] = {
        "metric_aggregation_type": "MetricAggregationType",
        "policy_type": "PolicyType",
        "predictive_scaling_configuration": "PredictiveScalingConfiguration",
        "scaling_adjustment": "ScalingAdjustment",
        "cooldown": "Cooldown",
        "step_adjustments": "StepAdjustments",
        "auto_scaling_group_name": "AutoScalingGroupName",
        "min_adjustment_magnitude": "MinAdjustmentMagnitude",
        "target_tracking_configuration": "TargetTrackingConfiguration",
        "estimated_instance_warmup": "EstimatedInstanceWarmup",
        "adjustment_type": "AdjustmentType",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    metric_aggregation_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    predictive_scaling_configuration: Optional[PredictiveScalingConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    scaling_adjustment: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cooldown: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    step_adjustments: Optional[list[StepAdjustment]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auto_scaling_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    min_adjustment_magnitude: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    target_tracking_configuration: Optional[TargetTrackingConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    estimated_instance_warmup: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    adjustment_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    @property
    def attr_policy_name(self) -> GetAtt:
        """Get the PolicyName attribute."""
        return self.get_att("PolicyName")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class ScheduledAction(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-autos"""

    resource_type: ClassVar[str] = "AWS::AutoScaling::ScheduledAction"
    _property_mappings: ClassVar[dict[str, str]] = {
        "min_size": "MinSize",
        "recurrence": "Recurrence",
        "time_zone": "TimeZone",
        "end_time": "EndTime",
        "auto_scaling_group_name": "AutoScalingGroupName",
        "start_time": "StartTime",
        "desired_capacity": "DesiredCapacity",
        "max_size": "MaxSize",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    min_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    recurrence: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    time_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    end_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auto_scaling_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    start_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    desired_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_size: Optional[Union[int, Ref, GetAtt, Sub]] = None

    @property
    def attr_scheduled_action_name(self) -> GetAtt:
        """Get the ScheduledActionName attribute."""
        return self.get_att("ScheduledActionName")




@dataclass
class InstanceReusePolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "reuse_on_scale_in": "ReuseOnScaleIn",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    reuse_on_scale_in: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class WarmPool(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-autos"""

    resource_type: ClassVar[str] = "AWS::AutoScaling::WarmPool"
    _property_mappings: ClassVar[dict[str, str]] = {
        "min_size": "MinSize",
        "max_group_prepared_capacity": "MaxGroupPreparedCapacity",
        "auto_scaling_group_name": "AutoScalingGroupName",
        "pool_state": "PoolState",
        "instance_reuse_policy": "InstanceReusePolicy",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    min_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_group_prepared_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auto_scaling_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    pool_state: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_reuse_policy: Optional[InstanceReusePolicy] = None



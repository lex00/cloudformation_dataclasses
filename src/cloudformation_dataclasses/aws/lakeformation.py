"""
AWS CloudFormation LakeFormation Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 21:37:50

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service LakeFormation
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class ApplicationStatus:
    """ApplicationStatus enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"


class ComparisonOperator:
    """ComparisonOperator enum values."""

    EQ = "EQ"
    NE = "NE"
    LE = "LE"
    LT = "LT"
    GE = "GE"
    GT = "GT"
    CONTAINS = "CONTAINS"
    NOT_CONTAINS = "NOT_CONTAINS"
    BEGINS_WITH = "BEGINS_WITH"
    IN = "IN"
    BETWEEN = "BETWEEN"


class DataLakeResourceType:
    """DataLakeResourceType enum values."""

    CATALOG = "CATALOG"
    DATABASE = "DATABASE"
    TABLE = "TABLE"
    DATA_LOCATION = "DATA_LOCATION"
    LF_TAG = "LF_TAG"
    LF_TAG_POLICY = "LF_TAG_POLICY"
    LF_TAG_POLICY_DATABASE = "LF_TAG_POLICY_DATABASE"
    LF_TAG_POLICY_TABLE = "LF_TAG_POLICY_TABLE"
    LF_NAMED_TAG_EXPRESSION = "LF_NAMED_TAG_EXPRESSION"


class EnableStatus:
    """EnableStatus enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"


class FieldNameString:
    """FieldNameString enum values."""

    RESOURCE_ARN = "RESOURCE_ARN"
    ROLE_ARN = "ROLE_ARN"
    LAST_MODIFIED = "LAST_MODIFIED"


class OptimizerType:
    """OptimizerType enum values."""

    COMPACTION = "COMPACTION"
    GARBAGE_COLLECTION = "GARBAGE_COLLECTION"
    ALL = "ALL"


class Permission:
    """Permission enum values."""

    ALL = "ALL"
    SELECT = "SELECT"
    ALTER = "ALTER"
    DROP = "DROP"
    DELETE = "DELETE"
    INSERT = "INSERT"
    DESCRIBE = "DESCRIBE"
    CREATE_DATABASE = "CREATE_DATABASE"
    CREATE_TABLE = "CREATE_TABLE"
    DATA_LOCATION_ACCESS = "DATA_LOCATION_ACCESS"
    CREATE_LF_TAG = "CREATE_LF_TAG"
    ASSOCIATE = "ASSOCIATE"
    GRANT_WITH_LF_TAG_EXPRESSION = "GRANT_WITH_LF_TAG_EXPRESSION"
    CREATE_LF_TAG_EXPRESSION = "CREATE_LF_TAG_EXPRESSION"
    CREATE_CATALOG = "CREATE_CATALOG"
    SUPER_USER = "SUPER_USER"


class PermissionType:
    """PermissionType enum values."""

    COLUMN_PERMISSION = "COLUMN_PERMISSION"
    CELL_FILTER_PERMISSION = "CELL_FILTER_PERMISSION"
    NESTED_PERMISSION = "NESTED_PERMISSION"
    NESTED_CELL_PERMISSION = "NESTED_CELL_PERMISSION"


class QueryStateString:
    """QueryStateString enum values."""

    PENDING = "PENDING"
    WORKUNITS_AVAILABLE = "WORKUNITS_AVAILABLE"
    ERROR = "ERROR"
    FINISHED = "FINISHED"
    EXPIRED = "EXPIRED"


class ResourceShareType:
    """ResourceShareType enum values."""

    FOREIGN = "FOREIGN"
    ALL = "ALL"


class ResourceType:
    """ResourceType enum values."""

    DATABASE = "DATABASE"
    TABLE = "TABLE"


class ServiceAuthorization:
    """ServiceAuthorization enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"


class TransactionStatus:
    """TransactionStatus enum values."""

    ACTIVE = "ACTIVE"
    COMMITTED = "COMMITTED"
    ABORTED = "ABORTED"
    COMMIT_IN_PROGRESS = "COMMIT_IN_PROGRESS"


class TransactionStatusFilter:
    """TransactionStatusFilter enum values."""

    ALL = "ALL"
    COMPLETED = "COMPLETED"
    ACTIVE = "ACTIVE"
    COMMITTED = "COMMITTED"
    ABORTED = "ABORTED"


class TransactionType:
    """TransactionType enum values."""

    READ_AND_WRITE = "READ_AND_WRITE"
    READ_ONLY = "READ_ONLY"


# Convenient aliases for enum values
ENABLED = ApplicationStatus.ENABLED
DISABLED = ApplicationStatus.DISABLED
EQ = ComparisonOperator.EQ
NE = ComparisonOperator.NE
LE = ComparisonOperator.LE
LT = ComparisonOperator.LT
GE = ComparisonOperator.GE
GT = ComparisonOperator.GT
CONTAINS = ComparisonOperator.CONTAINS
NOT_CONTAINS = ComparisonOperator.NOT_CONTAINS
BEGINS_WITH = ComparisonOperator.BEGINS_WITH
IN = ComparisonOperator.IN
BETWEEN = ComparisonOperator.BETWEEN
CATALOG = DataLakeResourceType.CATALOG
DATABASE = DataLakeResourceType.DATABASE
TABLE = DataLakeResourceType.TABLE
DATA_LOCATION = DataLakeResourceType.DATA_LOCATION
LF_TAG = DataLakeResourceType.LF_TAG
LF_TAG_POLICY = DataLakeResourceType.LF_TAG_POLICY
LF_TAG_POLICY_DATABASE = DataLakeResourceType.LF_TAG_POLICY_DATABASE
LF_TAG_POLICY_TABLE = DataLakeResourceType.LF_TAG_POLICY_TABLE
LF_NAMED_TAG_EXPRESSION = DataLakeResourceType.LF_NAMED_TAG_EXPRESSION
ENABLED = EnableStatus.ENABLED
DISABLED = EnableStatus.DISABLED
RESOURCE_ARN = FieldNameString.RESOURCE_ARN
ROLE_ARN = FieldNameString.ROLE_ARN
LAST_MODIFIED = FieldNameString.LAST_MODIFIED
COMPACTION = OptimizerType.COMPACTION
GARBAGE_COLLECTION = OptimizerType.GARBAGE_COLLECTION
ALL = OptimizerType.ALL
ALL = Permission.ALL
SELECT = Permission.SELECT
ALTER = Permission.ALTER
DROP = Permission.DROP
DELETE = Permission.DELETE
INSERT = Permission.INSERT
DESCRIBE = Permission.DESCRIBE
CREATE_DATABASE = Permission.CREATE_DATABASE
CREATE_TABLE = Permission.CREATE_TABLE
DATA_LOCATION_ACCESS = Permission.DATA_LOCATION_ACCESS
CREATE_LF_TAG = Permission.CREATE_LF_TAG
ASSOCIATE = Permission.ASSOCIATE
GRANT_WITH_LF_TAG_EXPRESSION = Permission.GRANT_WITH_LF_TAG_EXPRESSION
CREATE_LF_TAG_EXPRESSION = Permission.CREATE_LF_TAG_EXPRESSION
CREATE_CATALOG = Permission.CREATE_CATALOG
SUPER_USER = Permission.SUPER_USER
COLUMN_PERMISSION = PermissionType.COLUMN_PERMISSION
CELL_FILTER_PERMISSION = PermissionType.CELL_FILTER_PERMISSION
NESTED_PERMISSION = PermissionType.NESTED_PERMISSION
NESTED_CELL_PERMISSION = PermissionType.NESTED_CELL_PERMISSION
PENDING = QueryStateString.PENDING
WORKUNITS_AVAILABLE = QueryStateString.WORKUNITS_AVAILABLE
ERROR = QueryStateString.ERROR
FINISHED = QueryStateString.FINISHED
EXPIRED = QueryStateString.EXPIRED
FOREIGN = ResourceShareType.FOREIGN
ALL = ResourceShareType.ALL
DATABASE = ResourceType.DATABASE
TABLE = ResourceType.TABLE
ENABLED = ServiceAuthorization.ENABLED
DISABLED = ServiceAuthorization.DISABLED
ACTIVE = TransactionStatus.ACTIVE
COMMITTED = TransactionStatus.COMMITTED
ABORTED = TransactionStatus.ABORTED
COMMIT_IN_PROGRESS = TransactionStatus.COMMIT_IN_PROGRESS
ALL = TransactionStatusFilter.ALL
COMPLETED = TransactionStatusFilter.COMPLETED
ACTIVE = TransactionStatusFilter.ACTIVE
COMMITTED = TransactionStatusFilter.COMMITTED
ABORTED = TransactionStatusFilter.ABORTED
READ_AND_WRITE = TransactionType.READ_AND_WRITE
READ_ONLY = TransactionType.READ_ONLY


@dataclass
class ColumnWildcard:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "excluded_column_names": "ExcludedColumnNames",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    excluded_column_names: Optional[Union[list[str], Ref]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class RowFilter:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "all_rows_wildcard": "AllRowsWildcard",
        "filter_expression": "FilterExpression",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    all_rows_wildcard: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    filter_expression: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class DataCellsFilter(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lakef"""

    resource_type: ClassVar[str] = "AWS::LakeFormation::DataCellsFilter"
    _property_mappings: ClassVar[dict[str, str]] = {
        "table_name": "TableName",
        "column_names": "ColumnNames",
        "row_filter": "RowFilter",
        "database_name": "DatabaseName",
        "table_catalog_id": "TableCatalogId",
        "name": "Name",
        "column_wildcard": "ColumnWildcard",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    table_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    column_names: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    row_filter: Optional[RowFilter] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    database_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    table_catalog_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    column_wildcard: Optional[ColumnWildcard] = None



@dataclass
class Admins:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    pass


@dataclass
class CreateDatabaseDefaultPermissions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    pass


@dataclass
class CreateTableDefaultPermissions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    pass


@dataclass
class DataLakePrincipal:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "data_lake_principal_identifier": "DataLakePrincipalIdentifier",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_lake_principal_identifier: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class ExternalDataFilteringAllowList:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    pass


@dataclass
class PrincipalPermissions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "permissions": "Permissions",
        "principal": "Principal",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    permissions: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    principal: Optional[DataLakePrincipal] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class ReadOnlyAdmins:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    pass


@dataclass
class DataLakeSettings(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lakef"""

    resource_type: ClassVar[str] = "AWS::LakeFormation::DataLakeSettings"
    _property_mappings: ClassVar[dict[str, str]] = {
        "allow_external_data_filtering": "AllowExternalDataFiltering",
        "external_data_filtering_allow_list": "ExternalDataFilteringAllowList",
        "create_table_default_permissions": "CreateTableDefaultPermissions",
        "mutation_type": "MutationType",
        "parameters": "Parameters",
        "read_only_admins": "ReadOnlyAdmins",
        "allow_full_table_external_data_access": "AllowFullTableExternalDataAccess",
        "admins": "Admins",
        "create_database_default_permissions": "CreateDatabaseDefaultPermissions",
        "authorized_session_tag_value_list": "AuthorizedSessionTagValueList",
        "trusted_resource_owners": "TrustedResourceOwners",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    allow_external_data_filtering: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    external_data_filtering_allow_list: Optional[ExternalDataFilteringAllowList] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    create_table_default_permissions: Optional[CreateTableDefaultPermissions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    mutation_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    parameters: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    read_only_admins: Optional[ReadOnlyAdmins] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    allow_full_table_external_data_access: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    admins: Optional[Admins] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    create_database_default_permissions: Optional[CreateDatabaseDefaultPermissions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    authorized_session_tag_value_list: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    trusted_resource_owners: Optional[Union[list[str], Ref]] = None



@dataclass
class ColumnWildcard:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "excluded_column_names": "ExcludedColumnNames",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    excluded_column_names: Optional[Union[list[str], Ref]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class DataLakePrincipal:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "data_lake_principal_identifier": "DataLakePrincipalIdentifier",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_lake_principal_identifier: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class DataLocationResource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "s3_resource": "S3Resource",
        "catalog_id": "CatalogId",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_resource: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    catalog_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class DatabaseResource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "catalog_id": "CatalogId",
        "name": "Name",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    catalog_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class Resource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "table_resource": "TableResource",
        "database_resource": "DatabaseResource",
        "data_location_resource": "DataLocationResource",
        "table_with_columns_resource": "TableWithColumnsResource",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    table_resource: Optional[TableResource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    database_resource: Optional[DatabaseResource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_location_resource: Optional[DataLocationResource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    table_with_columns_resource: Optional[TableWithColumnsResource] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TableResource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "database_name": "DatabaseName",
        "catalog_id": "CatalogId",
        "table_wildcard": "TableWildcard",
        "name": "Name",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    database_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    catalog_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    table_wildcard: Optional[TableWildcard] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TableWildcard:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    pass


@dataclass
class TableWithColumnsResource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "column_names": "ColumnNames",
        "database_name": "DatabaseName",
        "catalog_id": "CatalogId",
        "name": "Name",
        "column_wildcard": "ColumnWildcard",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    column_names: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    database_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    catalog_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    column_wildcard: Optional[ColumnWildcard] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class Permissions(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lakef"""

    resource_type: ClassVar[str] = "AWS::LakeFormation::Permissions"
    _property_mappings: ClassVar[dict[str, str]] = {
        "data_lake_principal": "DataLakePrincipal",
        "resource": "Resource",
        "permissions": "Permissions",
        "permissions_with_grant_option": "PermissionsWithGrantOption",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    data_lake_principal: Optional[DataLakePrincipal] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resource: Optional[Resource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    permissions: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    permissions_with_grant_option: Optional[Union[list[str], Ref]] = None



@dataclass
class ColumnWildcard:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "excluded_column_names": "ExcludedColumnNames",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    excluded_column_names: Optional[Union[list[str], Ref]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class DataCellsFilterResource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "table_name": "TableName",
        "database_name": "DatabaseName",
        "table_catalog_id": "TableCatalogId",
        "name": "Name",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    table_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    database_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    table_catalog_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class DataLakePrincipal:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "data_lake_principal_identifier": "DataLakePrincipalIdentifier",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_lake_principal_identifier: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class DataLocationResource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "resource_arn": "ResourceArn",
        "catalog_id": "CatalogId",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    catalog_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class DatabaseResource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "catalog_id": "CatalogId",
        "name": "Name",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    catalog_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class LFTag:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "tag_key": "TagKey",
        "tag_values": "TagValues",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tag_key: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tag_values: Optional[Union[list[str], Ref]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class LFTagKeyResource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "tag_key": "TagKey",
        "catalog_id": "CatalogId",
        "tag_values": "TagValues",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tag_key: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    catalog_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tag_values: Optional[Union[list[str], Ref]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class LFTagPolicyResource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "expression": "Expression",
        "resource_type": "ResourceType",
        "catalog_id": "CatalogId",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    expression: Optional[list[LFTag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_type: Optional[Union[str, ResourceType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    catalog_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class Resource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "lf_tag": "LFTag",
        "table": "Table",
        "data_cells_filter": "DataCellsFilter",
        "table_with_columns": "TableWithColumns",
        "lf_tag_policy": "LFTagPolicy",
        "database": "Database",
        "data_location": "DataLocation",
        "catalog": "Catalog",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lf_tag: Optional[LFTagKeyResource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    table: Optional[TableResource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_cells_filter: Optional[DataCellsFilterResource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    table_with_columns: Optional[TableWithColumnsResource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lf_tag_policy: Optional[LFTagPolicyResource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    database: Optional[DatabaseResource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_location: Optional[DataLocationResource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    catalog: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TableResource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "database_name": "DatabaseName",
        "catalog_id": "CatalogId",
        "table_wildcard": "TableWildcard",
        "name": "Name",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    database_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    catalog_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    table_wildcard: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TableWithColumnsResource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "column_names": "ColumnNames",
        "database_name": "DatabaseName",
        "catalog_id": "CatalogId",
        "name": "Name",
        "column_wildcard": "ColumnWildcard",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    column_names: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    database_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    catalog_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    column_wildcard: Optional[ColumnWildcard] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class PrincipalPermissions(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lakef"""

    resource_type: ClassVar[str] = "AWS::LakeFormation::PrincipalPermissions"
    _property_mappings: ClassVar[dict[str, str]] = {
        "resource": "Resource",
        "permissions": "Permissions",
        "catalog": "Catalog",
        "principal": "Principal",
        "permissions_with_grant_option": "PermissionsWithGrantOption",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resource: Optional[Resource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    permissions: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    catalog: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    principal: Optional[DataLakePrincipal] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    permissions_with_grant_option: Optional[Union[list[str], Ref]] = None

    @property
    def attr_resource_identifier(self) -> GetAtt:
        """Get the ResourceIdentifier attribute."""
        return self.get_att("ResourceIdentifier")

    @property
    def attr_principal_identifier(self) -> GetAtt:
        """Get the PrincipalIdentifier attribute."""
        return self.get_att("PrincipalIdentifier")




@dataclass
class Resource(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lakef"""

    resource_type: ClassVar[str] = "AWS::LakeFormation::Resource"
    _property_mappings: ClassVar[dict[str, str]] = {
        "resource_arn": "ResourceArn",
        "with_federation": "WithFederation",
        "use_service_linked_role": "UseServiceLinkedRole",
        "hybrid_access_enabled": "HybridAccessEnabled",
        "role_arn": "RoleArn",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resource_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    with_federation: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    use_service_linked_role: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    hybrid_access_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None



@dataclass
class Tag(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lakef"""

    resource_type: ClassVar[str] = "AWS::LakeFormation::Tag"
    _property_mappings: ClassVar[dict[str, str]] = {
        "tag_key": "TagKey",
        "catalog_id": "CatalogId",
        "tag_values": "TagValues",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tag_key: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    catalog_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tag_values: Optional[Union[list[str], Ref]] = None



@dataclass
class DatabaseResource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "catalog_id": "CatalogId",
        "name": "Name",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    catalog_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class LFTagPair:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "tag_key": "TagKey",
        "catalog_id": "CatalogId",
        "tag_values": "TagValues",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tag_key: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    catalog_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tag_values: Optional[Union[list[str], Ref]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class Resource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "table": "Table",
        "table_with_columns": "TableWithColumns",
        "database": "Database",
        "catalog": "Catalog",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    table: Optional[TableResource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    table_with_columns: Optional[TableWithColumnsResource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    database: Optional[DatabaseResource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    catalog: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TableResource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "database_name": "DatabaseName",
        "catalog_id": "CatalogId",
        "table_wildcard": "TableWildcard",
        "name": "Name",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    database_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    catalog_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    table_wildcard: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TableWithColumnsResource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lak"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "column_names": "ColumnNames",
        "database_name": "DatabaseName",
        "catalog_id": "CatalogId",
        "name": "Name",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    column_names: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    database_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    catalog_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TagAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lakef"""

    resource_type: ClassVar[str] = "AWS::LakeFormation::TagAssociation"
    _property_mappings: ClassVar[dict[str, str]] = {
        "lf_tags": "LFTags",
        "resource": "Resource",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    lf_tags: Optional[list[LFTagPair]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resource: Optional[Resource] = None

    @property
    def attr_resource_identifier(self) -> GetAtt:
        """Get the ResourceIdentifier attribute."""
        return self.get_att("ResourceIdentifier")

    @property
    def attr_tags_identifier(self) -> GetAtt:
        """Get the TagsIdentifier attribute."""
        return self.get_att("TagsIdentifier")




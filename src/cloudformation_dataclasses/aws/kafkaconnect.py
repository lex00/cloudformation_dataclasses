"""
AWS CloudFormation KafkaConnect Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 21:37:48

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service KafkaConnect
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class ConnectorOperationState:
    """ConnectorOperationState enum values."""

    PENDING = "PENDING"
    UPDATE_IN_PROGRESS = "UPDATE_IN_PROGRESS"
    UPDATE_COMPLETE = "UPDATE_COMPLETE"
    UPDATE_FAILED = "UPDATE_FAILED"
    ROLLBACK_IN_PROGRESS = "ROLLBACK_IN_PROGRESS"
    ROLLBACK_FAILED = "ROLLBACK_FAILED"
    ROLLBACK_COMPLETE = "ROLLBACK_COMPLETE"


class ConnectorOperationStepState:
    """ConnectorOperationStepState enum values."""

    PENDING = "PENDING"
    IN_PROGRESS = "IN_PROGRESS"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    CANCELLED = "CANCELLED"


class ConnectorOperationStepType:
    """ConnectorOperationStepType enum values."""

    INITIALIZE_UPDATE = "INITIALIZE_UPDATE"
    FINALIZE_UPDATE = "FINALIZE_UPDATE"
    UPDATE_WORKER_SETTING = "UPDATE_WORKER_SETTING"
    UPDATE_CONNECTOR_CONFIGURATION = "UPDATE_CONNECTOR_CONFIGURATION"
    VALIDATE_UPDATE = "VALIDATE_UPDATE"


class ConnectorOperationType:
    """ConnectorOperationType enum values."""

    UPDATE_WORKER_SETTING = "UPDATE_WORKER_SETTING"
    UPDATE_CONNECTOR_CONFIGURATION = "UPDATE_CONNECTOR_CONFIGURATION"
    ISOLATE_CONNECTOR = "ISOLATE_CONNECTOR"
    RESTORE_CONNECTOR = "RESTORE_CONNECTOR"


class ConnectorState:
    """ConnectorState enum values."""

    RUNNING = "RUNNING"
    CREATING = "CREATING"
    UPDATING = "UPDATING"
    DELETING = "DELETING"
    FAILED = "FAILED"


class CustomPluginContentType:
    """CustomPluginContentType enum values."""

    JAR = "JAR"
    ZIP = "ZIP"


class CustomPluginState:
    """CustomPluginState enum values."""

    CREATING = "CREATING"
    CREATE_FAILED = "CREATE_FAILED"
    ACTIVE = "ACTIVE"
    UPDATING = "UPDATING"
    UPDATE_FAILED = "UPDATE_FAILED"
    DELETING = "DELETING"


class KafkaClusterClientAuthenticationType:
    """KafkaClusterClientAuthenticationType enum values."""

    NONE = "NONE"
    IAM = "IAM"


class KafkaClusterEncryptionInTransitType:
    """KafkaClusterEncryptionInTransitType enum values."""

    PLAINTEXT = "PLAINTEXT"
    TLS = "TLS"


class NetworkType:
    """NetworkType enum values."""

    IPV4 = "IPV4"
    DUAL = "DUAL"


class WorkerConfigurationState:
    """WorkerConfigurationState enum values."""

    ACTIVE = "ACTIVE"
    DELETING = "DELETING"


# Convenient aliases for enum values
PENDING = ConnectorOperationState.PENDING
UPDATE_IN_PROGRESS = ConnectorOperationState.UPDATE_IN_PROGRESS
UPDATE_COMPLETE = ConnectorOperationState.UPDATE_COMPLETE
UPDATE_FAILED = ConnectorOperationState.UPDATE_FAILED
ROLLBACK_IN_PROGRESS = ConnectorOperationState.ROLLBACK_IN_PROGRESS
ROLLBACK_FAILED = ConnectorOperationState.ROLLBACK_FAILED
ROLLBACK_COMPLETE = ConnectorOperationState.ROLLBACK_COMPLETE
PENDING = ConnectorOperationStepState.PENDING
IN_PROGRESS = ConnectorOperationStepState.IN_PROGRESS
COMPLETED = ConnectorOperationStepState.COMPLETED
FAILED = ConnectorOperationStepState.FAILED
CANCELLED = ConnectorOperationStepState.CANCELLED
INITIALIZE_UPDATE = ConnectorOperationStepType.INITIALIZE_UPDATE
FINALIZE_UPDATE = ConnectorOperationStepType.FINALIZE_UPDATE
UPDATE_WORKER_SETTING = ConnectorOperationStepType.UPDATE_WORKER_SETTING
UPDATE_CONNECTOR_CONFIGURATION = ConnectorOperationStepType.UPDATE_CONNECTOR_CONFIGURATION
VALIDATE_UPDATE = ConnectorOperationStepType.VALIDATE_UPDATE
UPDATE_WORKER_SETTING = ConnectorOperationType.UPDATE_WORKER_SETTING
UPDATE_CONNECTOR_CONFIGURATION = ConnectorOperationType.UPDATE_CONNECTOR_CONFIGURATION
ISOLATE_CONNECTOR = ConnectorOperationType.ISOLATE_CONNECTOR
RESTORE_CONNECTOR = ConnectorOperationType.RESTORE_CONNECTOR
RUNNING = ConnectorState.RUNNING
CREATING = ConnectorState.CREATING
UPDATING = ConnectorState.UPDATING
DELETING = ConnectorState.DELETING
FAILED = ConnectorState.FAILED
JAR = CustomPluginContentType.JAR
ZIP = CustomPluginContentType.ZIP
CREATING = CustomPluginState.CREATING
CREATE_FAILED = CustomPluginState.CREATE_FAILED
ACTIVE = CustomPluginState.ACTIVE
UPDATING = CustomPluginState.UPDATING
UPDATE_FAILED = CustomPluginState.UPDATE_FAILED
DELETING = CustomPluginState.DELETING
NONE = KafkaClusterClientAuthenticationType.NONE
IAM = KafkaClusterClientAuthenticationType.IAM
PLAINTEXT = KafkaClusterEncryptionInTransitType.PLAINTEXT
TLS = KafkaClusterEncryptionInTransitType.TLS
IPV4 = NetworkType.IPV4
DUAL = NetworkType.DUAL
ACTIVE = WorkerConfigurationState.ACTIVE
DELETING = WorkerConfigurationState.DELETING


@dataclass
class ApacheKafkaCluster:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kaf"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "vpc": "Vpc",
        "bootstrap_servers": "BootstrapServers",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc: Optional[Vpc] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bootstrap_servers: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class AutoScaling:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kaf"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "scale_out_policy": "ScaleOutPolicy",
        "scale_in_policy": "ScaleInPolicy",
        "max_worker_count": "MaxWorkerCount",
        "min_worker_count": "MinWorkerCount",
        "mcu_count": "McuCount",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scale_out_policy: Optional[ScaleOutPolicy] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scale_in_policy: Optional[ScaleInPolicy] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_worker_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min_worker_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mcu_count: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class Capacity:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kaf"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "provisioned_capacity": "ProvisionedCapacity",
        "auto_scaling": "AutoScaling",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    provisioned_capacity: Optional[ProvisionedCapacity] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    auto_scaling: Optional[AutoScaling] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class CloudWatchLogsLogDelivery:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kaf"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "log_group": "LogGroup",
        "enabled": "Enabled",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_group: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class CustomPlugin:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kaf"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "custom_plugin_arn": "CustomPluginArn",
        "revision": "Revision",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_plugin_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    revision: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class FirehoseLogDelivery:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kaf"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "delivery_stream": "DeliveryStream",
        "enabled": "Enabled",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    delivery_stream: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class KafkaCluster:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kaf"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "apache_kafka_cluster": "ApacheKafkaCluster",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    apache_kafka_cluster: Optional[ApacheKafkaCluster] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class KafkaClusterClientAuthentication:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kaf"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "authentication_type": "AuthenticationType",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    authentication_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class KafkaClusterEncryptionInTransit:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kaf"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "encryption_type": "EncryptionType",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    encryption_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class LogDelivery:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kaf"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "worker_log_delivery": "WorkerLogDelivery",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    worker_log_delivery: Optional[WorkerLogDelivery] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class Plugin:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kaf"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "custom_plugin": "CustomPlugin",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_plugin: Optional[CustomPlugin] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class ProvisionedCapacity:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kaf"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "worker_count": "WorkerCount",
        "mcu_count": "McuCount",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    worker_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mcu_count: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class S3LogDelivery:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kaf"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "bucket": "Bucket",
        "enabled": "Enabled",
        "prefix": "Prefix",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bucket: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class ScaleInPolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kaf"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "cpu_utilization_percentage": "CpuUtilizationPercentage",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu_utilization_percentage: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class ScaleOutPolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kaf"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "cpu_utilization_percentage": "CpuUtilizationPercentage",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu_utilization_percentage: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class Vpc:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kaf"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "security_groups": "SecurityGroups",
        "subnets": "Subnets",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_groups: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnets: Optional[Union[list[str], Ref]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class WorkerConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kaf"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "revision": "Revision",
        "worker_configuration_arn": "WorkerConfigurationArn",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    revision: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    worker_configuration_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class WorkerLogDelivery:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kaf"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "s3": "S3",
        "firehose": "Firehose",
        "cloud_watch_logs": "CloudWatchLogs",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3: Optional[S3LogDelivery] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    firehose: Optional[FirehoseLogDelivery] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloud_watch_logs: Optional[CloudWatchLogsLogDelivery] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class Connector(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kafka"""

    resource_type: ClassVar[str] = "AWS::KafkaConnect::Connector"
    _property_mappings: ClassVar[dict[str, str]] = {
        "kafka_cluster": "KafkaCluster",
        "kafka_connect_version": "KafkaConnectVersion",
        "connector_configuration": "ConnectorConfiguration",
        "log_delivery": "LogDelivery",
        "worker_configuration": "WorkerConfiguration",
        "capacity": "Capacity",
        "kafka_cluster_encryption_in_transit": "KafkaClusterEncryptionInTransit",
        "connector_description": "ConnectorDescription",
        "kafka_cluster_client_authentication": "KafkaClusterClientAuthentication",
        "connector_name": "ConnectorName",
        "service_execution_role_arn": "ServiceExecutionRoleArn",
        "tags": "Tags",
        "plugins": "Plugins",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kafka_cluster: Optional[KafkaCluster] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kafka_connect_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    connector_configuration: Optional[dict[str, str]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    log_delivery: Optional[LogDelivery] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    worker_configuration: Optional[WorkerConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    capacity: Optional[Capacity] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kafka_cluster_encryption_in_transit: Optional[KafkaClusterEncryptionInTransit] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    connector_description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kafka_cluster_client_authentication: Optional[KafkaClusterClientAuthentication] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    connector_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    service_execution_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    plugins: Optional[list[Plugin]] = None

    @property
    def attr_connector_arn(self) -> GetAtt:
        """Get the ConnectorArn attribute."""
        return self.get_att("ConnectorArn")




@dataclass
class CustomPluginFileDescription:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kaf"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "file_md5": "FileMd5",
        "file_size": "FileSize",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    file_md5: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    file_size: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class CustomPluginLocation:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kaf"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "s3_location": "S3Location",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_location: Optional[S3Location] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class S3Location:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kaf"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "bucket_arn": "BucketArn",
        "file_key": "FileKey",
        "object_version": "ObjectVersion",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bucket_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    file_key: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    object_version: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class CustomPlugin(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kafka"""

    resource_type: ClassVar[str] = "AWS::KafkaConnect::CustomPlugin"
    _property_mappings: ClassVar[dict[str, str]] = {
        "description": "Description",
        "content_type": "ContentType",
        "tags": "Tags",
        "name": "Name",
        "location": "Location",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    content_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    location: Optional[CustomPluginLocation] = None

    @property
    def attr_custom_plugin_arn(self) -> GetAtt:
        """Get the CustomPluginArn attribute."""
        return self.get_att("CustomPluginArn")

    @property
    def attr_file_description(self) -> GetAtt:
        """Get the FileDescription attribute."""
        return self.get_att("FileDescription")

    @property
    def attr_file_description__file_md5(self) -> GetAtt:
        """Get the FileDescription.FileMd5 attribute."""
        return self.get_att("FileDescription.FileMd5")

    @property
    def attr_revision(self) -> GetAtt:
        """Get the Revision attribute."""
        return self.get_att("Revision")

    @property
    def attr_file_description__file_size(self) -> GetAtt:
        """Get the FileDescription.FileSize attribute."""
        return self.get_att("FileDescription.FileSize")




@dataclass
class WorkerConfiguration(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kafka"""

    resource_type: ClassVar[str] = "AWS::KafkaConnect::WorkerConfiguration"
    _property_mappings: ClassVar[dict[str, str]] = {
        "properties_file_content": "PropertiesFileContent",
        "description": "Description",
        "tags": "Tags",
        "name": "Name",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    properties_file_content: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    @property
    def attr_revision(self) -> GetAtt:
        """Get the Revision attribute."""
        return self.get_att("Revision")

    @property
    def attr_worker_configuration_arn(self) -> GetAtt:
        """Get the WorkerConfigurationArn attribute."""
        return self.get_att("WorkerConfigurationArn")




"""
AWS CloudFormation Athena Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 21:37:31

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service Athena
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class AuthenticationType:
    """AuthenticationType enum values."""

    DIRECTORY_IDENTITY = "DIRECTORY_IDENTITY"


class CalculationExecutionState:
    """CalculationExecutionState enum values."""

    CREATING = "CREATING"
    CREATED = "CREATED"
    QUEUED = "QUEUED"
    RUNNING = "RUNNING"
    CANCELING = "CANCELING"
    CANCELED = "CANCELED"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"


class CapacityAllocationStatus:
    """CapacityAllocationStatus enum values."""

    PENDING = "PENDING"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"


class CapacityReservationStatus:
    """CapacityReservationStatus enum values."""

    PENDING = "PENDING"
    ACTIVE = "ACTIVE"
    CANCELLING = "CANCELLING"
    CANCELLED = "CANCELLED"
    FAILED = "FAILED"
    UPDATE_PENDING = "UPDATE_PENDING"


class ColumnNullable:
    """ColumnNullable enum values."""

    NOT_NULL = "NOT_NULL"
    NULLABLE = "NULLABLE"
    UNKNOWN = "UNKNOWN"


class ConnectionType:
    """ConnectionType enum values."""

    DYNAMODB = "DYNAMODB"
    MYSQL = "MYSQL"
    POSTGRESQL = "POSTGRESQL"
    REDSHIFT = "REDSHIFT"
    ORACLE = "ORACLE"
    SYNAPSE = "SYNAPSE"
    SQLSERVER = "SQLSERVER"
    DB2 = "DB2"
    OPENSEARCH = "OPENSEARCH"
    BIGQUERY = "BIGQUERY"
    GOOGLECLOUDSTORAGE = "GOOGLECLOUDSTORAGE"
    HBASE = "HBASE"
    DOCUMENTDB = "DOCUMENTDB"
    CMDB = "CMDB"
    TPCDS = "TPCDS"
    TIMESTREAM = "TIMESTREAM"
    SAPHANA = "SAPHANA"
    SNOWFLAKE = "SNOWFLAKE"
    DATALAKEGEN2 = "DATALAKEGEN2"
    DB2AS400 = "DB2AS400"


class DataCatalogStatus:
    """DataCatalogStatus enum values."""

    CREATE_IN_PROGRESS = "CREATE_IN_PROGRESS"
    CREATE_COMPLETE = "CREATE_COMPLETE"
    CREATE_FAILED = "CREATE_FAILED"
    CREATE_FAILED_CLEANUP_IN_PROGRESS = "CREATE_FAILED_CLEANUP_IN_PROGRESS"
    CREATE_FAILED_CLEANUP_COMPLETE = "CREATE_FAILED_CLEANUP_COMPLETE"
    CREATE_FAILED_CLEANUP_FAILED = "CREATE_FAILED_CLEANUP_FAILED"
    DELETE_IN_PROGRESS = "DELETE_IN_PROGRESS"
    DELETE_COMPLETE = "DELETE_COMPLETE"
    DELETE_FAILED = "DELETE_FAILED"


class DataCatalogType:
    """DataCatalogType enum values."""

    LAMBDA = "LAMBDA"
    GLUE = "GLUE"
    HIVE = "HIVE"
    FEDERATED = "FEDERATED"


class EncryptionOption:
    """EncryptionOption enum values."""

    SSE_S3 = "SSE_S3"
    SSE_KMS = "SSE_KMS"
    CSE_KMS = "CSE_KMS"


class ExecutorState:
    """ExecutorState enum values."""

    CREATING = "CREATING"
    CREATED = "CREATED"
    REGISTERED = "REGISTERED"
    TERMINATING = "TERMINATING"
    TERMINATED = "TERMINATED"
    FAILED = "FAILED"


class ExecutorType:
    """ExecutorType enum values."""

    COORDINATOR = "COORDINATOR"
    GATEWAY = "GATEWAY"
    WORKER = "WORKER"


class NotebookType:
    """NotebookType enum values."""

    IPYNB = "IPYNB"


class QueryExecutionState:
    """QueryExecutionState enum values."""

    QUEUED = "QUEUED"
    RUNNING = "RUNNING"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    CANCELLED = "CANCELLED"


class QueryResultType:
    """QueryResultType enum values."""

    DATA_MANIFEST = "DATA_MANIFEST"
    DATA_ROWS = "DATA_ROWS"


class S3AclOption:
    """S3AclOption enum values."""

    BUCKET_OWNER_FULL_CONTROL = "BUCKET_OWNER_FULL_CONTROL"


class SessionState:
    """SessionState enum values."""

    CREATING = "CREATING"
    CREATED = "CREATED"
    IDLE = "IDLE"
    BUSY = "BUSY"
    TERMINATING = "TERMINATING"
    TERMINATED = "TERMINATED"
    DEGRADED = "DEGRADED"
    FAILED = "FAILED"


class StatementType:
    """StatementType enum values."""

    DDL = "DDL"
    DML = "DML"
    UTILITY = "UTILITY"


class ThrottleReason:
    """ThrottleReason enum values."""

    CONCURRENT_QUERY_LIMIT_EXCEEDED = "CONCURRENT_QUERY_LIMIT_EXCEEDED"


class WorkGroupState:
    """WorkGroupState enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"


# Convenient aliases for enum values
DIRECTORY_IDENTITY = AuthenticationType.DIRECTORY_IDENTITY
CREATING = CalculationExecutionState.CREATING
CREATED = CalculationExecutionState.CREATED
QUEUED = CalculationExecutionState.QUEUED
RUNNING = CalculationExecutionState.RUNNING
CANCELING = CalculationExecutionState.CANCELING
CANCELED = CalculationExecutionState.CANCELED
COMPLETED = CalculationExecutionState.COMPLETED
FAILED = CalculationExecutionState.FAILED
PENDING = CapacityAllocationStatus.PENDING
SUCCEEDED = CapacityAllocationStatus.SUCCEEDED
FAILED = CapacityAllocationStatus.FAILED
PENDING = CapacityReservationStatus.PENDING
ACTIVE = CapacityReservationStatus.ACTIVE
CANCELLING = CapacityReservationStatus.CANCELLING
CANCELLED = CapacityReservationStatus.CANCELLED
FAILED = CapacityReservationStatus.FAILED
UPDATE_PENDING = CapacityReservationStatus.UPDATE_PENDING
NOT_NULL = ColumnNullable.NOT_NULL
NULLABLE = ColumnNullable.NULLABLE
UNKNOWN = ColumnNullable.UNKNOWN
DYNAMODB = ConnectionType.DYNAMODB
MYSQL = ConnectionType.MYSQL
POSTGRESQL = ConnectionType.POSTGRESQL
REDSHIFT = ConnectionType.REDSHIFT
ORACLE = ConnectionType.ORACLE
SYNAPSE = ConnectionType.SYNAPSE
SQLSERVER = ConnectionType.SQLSERVER
DB2 = ConnectionType.DB2
OPENSEARCH = ConnectionType.OPENSEARCH
BIGQUERY = ConnectionType.BIGQUERY
GOOGLECLOUDSTORAGE = ConnectionType.GOOGLECLOUDSTORAGE
HBASE = ConnectionType.HBASE
DOCUMENTDB = ConnectionType.DOCUMENTDB
CMDB = ConnectionType.CMDB
TPCDS = ConnectionType.TPCDS
TIMESTREAM = ConnectionType.TIMESTREAM
SAPHANA = ConnectionType.SAPHANA
SNOWFLAKE = ConnectionType.SNOWFLAKE
DATALAKEGEN2 = ConnectionType.DATALAKEGEN2
DB2AS400 = ConnectionType.DB2AS400
CREATE_IN_PROGRESS = DataCatalogStatus.CREATE_IN_PROGRESS
CREATE_COMPLETE = DataCatalogStatus.CREATE_COMPLETE
CREATE_FAILED = DataCatalogStatus.CREATE_FAILED
CREATE_FAILED_CLEANUP_IN_PROGRESS = DataCatalogStatus.CREATE_FAILED_CLEANUP_IN_PROGRESS
CREATE_FAILED_CLEANUP_COMPLETE = DataCatalogStatus.CREATE_FAILED_CLEANUP_COMPLETE
CREATE_FAILED_CLEANUP_FAILED = DataCatalogStatus.CREATE_FAILED_CLEANUP_FAILED
DELETE_IN_PROGRESS = DataCatalogStatus.DELETE_IN_PROGRESS
DELETE_COMPLETE = DataCatalogStatus.DELETE_COMPLETE
DELETE_FAILED = DataCatalogStatus.DELETE_FAILED
LAMBDA = DataCatalogType.LAMBDA
GLUE = DataCatalogType.GLUE
HIVE = DataCatalogType.HIVE
FEDERATED = DataCatalogType.FEDERATED
SSE_S3 = EncryptionOption.SSE_S3
SSE_KMS = EncryptionOption.SSE_KMS
CSE_KMS = EncryptionOption.CSE_KMS
CREATING = ExecutorState.CREATING
CREATED = ExecutorState.CREATED
REGISTERED = ExecutorState.REGISTERED
TERMINATING = ExecutorState.TERMINATING
TERMINATED = ExecutorState.TERMINATED
FAILED = ExecutorState.FAILED
COORDINATOR = ExecutorType.COORDINATOR
GATEWAY = ExecutorType.GATEWAY
WORKER = ExecutorType.WORKER
IPYNB = NotebookType.IPYNB
QUEUED = QueryExecutionState.QUEUED
RUNNING = QueryExecutionState.RUNNING
SUCCEEDED = QueryExecutionState.SUCCEEDED
FAILED = QueryExecutionState.FAILED
CANCELLED = QueryExecutionState.CANCELLED
DATA_MANIFEST = QueryResultType.DATA_MANIFEST
DATA_ROWS = QueryResultType.DATA_ROWS
BUCKET_OWNER_FULL_CONTROL = S3AclOption.BUCKET_OWNER_FULL_CONTROL
CREATING = SessionState.CREATING
CREATED = SessionState.CREATED
IDLE = SessionState.IDLE
BUSY = SessionState.BUSY
TERMINATING = SessionState.TERMINATING
TERMINATED = SessionState.TERMINATED
DEGRADED = SessionState.DEGRADED
FAILED = SessionState.FAILED
DDL = StatementType.DDL
DML = StatementType.DML
UTILITY = StatementType.UTILITY
CONCURRENT_QUERY_LIMIT_EXCEEDED = ThrottleReason.CONCURRENT_QUERY_LIMIT_EXCEEDED
ENABLED = WorkGroupState.ENABLED
DISABLED = WorkGroupState.DISABLED


@dataclass
class CapacityAssignment:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "workgroup_names": "WorkgroupNames",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    workgroup_names: Optional[Union[list[str], Ref]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class CapacityAssignmentConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "capacity_assignments": "CapacityAssignments",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_assignments: Optional[list[CapacityAssignment]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class CapacityReservation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-athen"""

    resource_type: ClassVar[str] = "AWS::Athena::CapacityReservation"
    _property_mappings: ClassVar[dict[str, str]] = {
        "target_dpus": "TargetDpus",
        "capacity_assignment_configuration": "CapacityAssignmentConfiguration",
        "tags": "Tags",
        "name": "Name",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    target_dpus: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    capacity_assignment_configuration: Optional[CapacityAssignmentConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_allocated_dpus(self) -> GetAtt:
        """Get the AllocatedDpus attribute."""
        return self.get_att("AllocatedDpus")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_last_successful_allocation_time(self) -> GetAtt:
        """Get the LastSuccessfulAllocationTime attribute."""
        return self.get_att("LastSuccessfulAllocationTime")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class DataCatalog(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-athen"""

    resource_type: ClassVar[str] = "AWS::Athena::DataCatalog"
    _property_mappings: ClassVar[dict[str, str]] = {
        "status": "Status",
        "type_": "Type",
        "description": "Description",
        "parameters": "Parameters",
        "connection_type": "ConnectionType",
        "error": "Error",
        "tags": "Tags",
        "name": "Name",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    status: Optional[Union[str, DataCatalogStatus, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_: Optional[Union[str, DataCatalogType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    parameters: Optional[dict[str, str]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    connection_type: Optional[Union[str, ConnectionType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    error: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None



@dataclass
class NamedQuery(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-athen"""

    resource_type: ClassVar[str] = "AWS::Athena::NamedQuery"
    _property_mappings: ClassVar[dict[str, str]] = {
        "work_group": "WorkGroup",
        "description": "Description",
        "query_string": "QueryString",
        "database": "Database",
        "name": "Name",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    work_group: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    query_string: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    database: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    @property
    def attr_named_query_id(self) -> GetAtt:
        """Get the NamedQueryId attribute."""
        return self.get_att("NamedQueryId")




@dataclass
class PreparedStatement(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-athen"""

    resource_type: ClassVar[str] = "AWS::Athena::PreparedStatement"
    _property_mappings: ClassVar[dict[str, str]] = {
        "statement_name": "StatementName",
        "work_group": "WorkGroup",
        "description": "Description",
        "query_statement": "QueryStatement",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    statement_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    work_group: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    query_statement: Optional[Union[str, Ref, GetAtt, Sub]] = None



@dataclass
class AclConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "s3_acl_option": "S3AclOption",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_acl_option: Optional[Union[str, S3AclOption, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class Classification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "properties": "Properties",
        "name": "Name",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    properties: Optional[dict[str, str]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class CloudWatchLoggingConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "log_group": "LogGroup",
        "enabled": "Enabled",
        "log_stream_name_prefix": "LogStreamNamePrefix",
        "log_types": "LogTypes",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_group: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_stream_name_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_types: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class CustomerContentEncryptionConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "kms_key": "KmsKey",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class EncryptionConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "encryption_option": "EncryptionOption",
        "kms_key": "KmsKey",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    encryption_option: Optional[Union[str, EncryptionOption, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class EngineConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "spark_properties": "SparkProperties",
        "classifications": "Classifications",
        "max_concurrent_dpus": "MaxConcurrentDpus",
        "coordinator_dpu_size": "CoordinatorDpuSize",
        "default_executor_dpu_size": "DefaultExecutorDpuSize",
        "additional_configs": "AdditionalConfigs",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spark_properties: Optional[dict[str, str]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    classifications: Optional[list[Classification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_concurrent_dpus: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    coordinator_dpu_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_executor_dpu_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    additional_configs: Optional[dict[str, str]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class EngineVersion:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "selected_engine_version": "SelectedEngineVersion",
        "effective_engine_version": "EffectiveEngineVersion",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    selected_engine_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    effective_engine_version: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class ManagedLoggingConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "enabled": "Enabled",
        "kms_key": "KmsKey",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class ManagedQueryResultsConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "encryption_configuration": "EncryptionConfiguration",
        "enabled": "Enabled",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    encryption_configuration: Optional[ManagedStorageEncryptionConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class ManagedStorageEncryptionConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "kms_key": "KmsKey",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class MonitoringConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "s3_logging_configuration": "S3LoggingConfiguration",
        "managed_logging_configuration": "ManagedLoggingConfiguration",
        "cloud_watch_logging_configuration": "CloudWatchLoggingConfiguration",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_logging_configuration: Optional[S3LoggingConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    managed_logging_configuration: Optional[ManagedLoggingConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloud_watch_logging_configuration: Optional[CloudWatchLoggingConfiguration] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class ResultConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "encryption_configuration": "EncryptionConfiguration",
        "output_location": "OutputLocation",
        "acl_configuration": "AclConfiguration",
        "expected_bucket_owner": "ExpectedBucketOwner",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    encryption_configuration: Optional[EncryptionConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    output_location: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    acl_configuration: Optional[AclConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    expected_bucket_owner: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class S3LoggingConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "log_location": "LogLocation",
        "enabled": "Enabled",
        "kms_key": "KmsKey",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_location: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class WorkGroupConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "enforce_work_group_configuration": "EnforceWorkGroupConfiguration",
        "engine_version": "EngineVersion",
        "publish_cloud_watch_metrics_enabled": "PublishCloudWatchMetricsEnabled",
        "result_configuration": "ResultConfiguration",
        "additional_configuration": "AdditionalConfiguration",
        "engine_configuration": "EngineConfiguration",
        "customer_content_encryption_configuration": "CustomerContentEncryptionConfiguration",
        "bytes_scanned_cutoff_per_query": "BytesScannedCutoffPerQuery",
        "monitoring_configuration": "MonitoringConfiguration",
        "requester_pays_enabled": "RequesterPaysEnabled",
        "managed_query_results_configuration": "ManagedQueryResultsConfiguration",
        "execution_role": "ExecutionRole",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enforce_work_group_configuration: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    engine_version: Optional[EngineVersion] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    publish_cloud_watch_metrics_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    result_configuration: Optional[ResultConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    additional_configuration: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    engine_configuration: Optional[EngineConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    customer_content_encryption_configuration: Optional[CustomerContentEncryptionConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bytes_scanned_cutoff_per_query: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    monitoring_configuration: Optional[MonitoringConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    requester_pays_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    managed_query_results_configuration: Optional[ManagedQueryResultsConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    execution_role: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class WorkGroup(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-athen"""

    resource_type: ClassVar[str] = "AWS::Athena::WorkGroup"
    _property_mappings: ClassVar[dict[str, str]] = {
        "recursive_delete_option": "RecursiveDeleteOption",
        "work_group_configuration": "WorkGroupConfiguration",
        "description": "Description",
        "state": "State",
        "tags": "Tags",
        "name": "Name",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    recursive_delete_option: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    work_group_configuration: Optional[WorkGroupConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    state: Optional[Union[str, WorkGroupState, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_work_group_configuration__engine_version__effective_engine_version(self) -> GetAtt:
        """Get the WorkGroupConfiguration.EngineVersion.EffectiveEngineVersion attribute."""
        return self.get_att("WorkGroupConfiguration.EngineVersion.EffectiveEngineVersion")




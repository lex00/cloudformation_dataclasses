"""
AWS CloudFormation CodeDeploy Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 21:37:36

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service CodeDeploy
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class ApplicationRevisionSortBy:
    """ApplicationRevisionSortBy enum values."""

    REGISTERTIME = "registerTime"
    FIRSTUSEDTIME = "firstUsedTime"
    LASTUSEDTIME = "lastUsedTime"


class AutoRollbackEvent:
    """AutoRollbackEvent enum values."""

    DEPLOYMENT_FAILURE = "DEPLOYMENT_FAILURE"
    DEPLOYMENT_STOP_ON_ALARM = "DEPLOYMENT_STOP_ON_ALARM"
    DEPLOYMENT_STOP_ON_REQUEST = "DEPLOYMENT_STOP_ON_REQUEST"


class BundleType:
    """BundleType enum values."""

    TAR = "tar"
    TGZ = "tgz"
    ZIP = "zip"
    YAML = "YAML"
    JSON = "JSON"


class ComputePlatform:
    """ComputePlatform enum values."""

    SERVER = "Server"
    LAMBDA = "Lambda"
    ECS = "ECS"


class DeploymentCreator:
    """DeploymentCreator enum values."""

    USER = "user"
    AUTOSCALING = "autoscaling"
    CODEDEPLOYROLLBACK = "codeDeployRollback"
    CODEDEPLOY = "CodeDeploy"
    CODEDEPLOYAUTOUPDATE = "CodeDeployAutoUpdate"
    CLOUDFORMATION = "CloudFormation"
    CLOUDFORMATIONROLLBACK = "CloudFormationRollback"
    AUTOSCALINGTERMINATION = "autoscalingTermination"


class DeploymentOption:
    """DeploymentOption enum values."""

    WITH_TRAFFIC_CONTROL = "WITH_TRAFFIC_CONTROL"
    WITHOUT_TRAFFIC_CONTROL = "WITHOUT_TRAFFIC_CONTROL"


class DeploymentReadyAction:
    """DeploymentReadyAction enum values."""

    CONTINUE_DEPLOYMENT = "CONTINUE_DEPLOYMENT"
    STOP_DEPLOYMENT = "STOP_DEPLOYMENT"


class DeploymentStatus:
    """DeploymentStatus enum values."""

    CREATED = "Created"
    QUEUED = "Queued"
    INPROGRESS = "InProgress"
    BAKING = "Baking"
    SUCCEEDED = "Succeeded"
    FAILED = "Failed"
    STOPPED = "Stopped"
    READY = "Ready"


class DeploymentTargetType:
    """DeploymentTargetType enum values."""

    INSTANCETARGET = "InstanceTarget"
    LAMBDATARGET = "LambdaTarget"
    ECSTARGET = "ECSTarget"
    CLOUDFORMATIONTARGET = "CloudFormationTarget"


class DeploymentType:
    """DeploymentType enum values."""

    IN_PLACE = "IN_PLACE"
    BLUE_GREEN = "BLUE_GREEN"


class DeploymentWaitType:
    """DeploymentWaitType enum values."""

    READY_WAIT = "READY_WAIT"
    TERMINATION_WAIT = "TERMINATION_WAIT"


class EC2TagFilterType:
    """EC2TagFilterType enum values."""

    KEY_ONLY = "KEY_ONLY"
    VALUE_ONLY = "VALUE_ONLY"
    KEY_AND_VALUE = "KEY_AND_VALUE"


class ErrorCode:
    """ErrorCode enum values."""

    AGENT_ISSUE = "AGENT_ISSUE"
    ALARM_ACTIVE = "ALARM_ACTIVE"
    APPLICATION_MISSING = "APPLICATION_MISSING"
    AUTOSCALING_VALIDATION_ERROR = "AUTOSCALING_VALIDATION_ERROR"
    AUTO_SCALING_CONFIGURATION = "AUTO_SCALING_CONFIGURATION"
    AUTO_SCALING_IAM_ROLE_PERMISSIONS = "AUTO_SCALING_IAM_ROLE_PERMISSIONS"
    CODEDEPLOY_RESOURCE_CANNOT_BE_FOUND = "CODEDEPLOY_RESOURCE_CANNOT_BE_FOUND"
    CUSTOMER_APPLICATION_UNHEALTHY = "CUSTOMER_APPLICATION_UNHEALTHY"
    DEPLOYMENT_GROUP_MISSING = "DEPLOYMENT_GROUP_MISSING"
    ECS_UPDATE_ERROR = "ECS_UPDATE_ERROR"
    ELASTIC_LOAD_BALANCING_INVALID = "ELASTIC_LOAD_BALANCING_INVALID"
    ELB_INVALID_INSTANCE = "ELB_INVALID_INSTANCE"
    HEALTH_CONSTRAINTS = "HEALTH_CONSTRAINTS"
    HEALTH_CONSTRAINTS_INVALID = "HEALTH_CONSTRAINTS_INVALID"
    HOOK_EXECUTION_FAILURE = "HOOK_EXECUTION_FAILURE"
    IAM_ROLE_MISSING = "IAM_ROLE_MISSING"
    IAM_ROLE_PERMISSIONS = "IAM_ROLE_PERMISSIONS"
    INTERNAL_ERROR = "INTERNAL_ERROR"
    INVALID_ECS_SERVICE = "INVALID_ECS_SERVICE"
    INVALID_LAMBDA_CONFIGURATION = "INVALID_LAMBDA_CONFIGURATION"
    INVALID_LAMBDA_FUNCTION = "INVALID_LAMBDA_FUNCTION"
    INVALID_REVISION = "INVALID_REVISION"
    MANUAL_STOP = "MANUAL_STOP"
    MISSING_BLUE_GREEN_DEPLOYMENT_CONFIGURATION = "MISSING_BLUE_GREEN_DEPLOYMENT_CONFIGURATION"
    MISSING_ELB_INFORMATION = "MISSING_ELB_INFORMATION"
    MISSING_GITHUB_TOKEN = "MISSING_GITHUB_TOKEN"
    NO_EC2_SUBSCRIPTION = "NO_EC2_SUBSCRIPTION"
    NO_INSTANCES = "NO_INSTANCES"
    OVER_MAX_INSTANCES = "OVER_MAX_INSTANCES"
    RESOURCE_LIMIT_EXCEEDED = "RESOURCE_LIMIT_EXCEEDED"
    REVISION_MISSING = "REVISION_MISSING"
    THROTTLED = "THROTTLED"
    TIMEOUT = "TIMEOUT"
    CLOUDFORMATION_STACK_FAILURE = "CLOUDFORMATION_STACK_FAILURE"


class FileExistsBehavior:
    """FileExistsBehavior enum values."""

    DISALLOW = "DISALLOW"
    OVERWRITE = "OVERWRITE"
    RETAIN = "RETAIN"


class GreenFleetProvisioningAction:
    """GreenFleetProvisioningAction enum values."""

    DISCOVER_EXISTING = "DISCOVER_EXISTING"
    COPY_AUTO_SCALING_GROUP = "COPY_AUTO_SCALING_GROUP"


class InstanceAction:
    """InstanceAction enum values."""

    TERMINATE = "TERMINATE"
    KEEP_ALIVE = "KEEP_ALIVE"


class InstanceStatus:
    """InstanceStatus enum values."""

    PENDING = "Pending"
    INPROGRESS = "InProgress"
    SUCCEEDED = "Succeeded"
    FAILED = "Failed"
    SKIPPED = "Skipped"
    UNKNOWN = "Unknown"
    READY = "Ready"


class InstanceType:
    """InstanceType enum values."""

    BLUE = "Blue"
    GREEN = "Green"


class LifecycleErrorCode:
    """LifecycleErrorCode enum values."""

    SUCCESS = "Success"
    SCRIPTMISSING = "ScriptMissing"
    SCRIPTNOTEXECUTABLE = "ScriptNotExecutable"
    SCRIPTTIMEDOUT = "ScriptTimedOut"
    SCRIPTFAILED = "ScriptFailed"
    UNKNOWNERROR = "UnknownError"


class LifecycleEventStatus:
    """LifecycleEventStatus enum values."""

    PENDING = "Pending"
    INPROGRESS = "InProgress"
    SUCCEEDED = "Succeeded"
    FAILED = "Failed"
    SKIPPED = "Skipped"
    UNKNOWN = "Unknown"


class ListStateFilterAction:
    """ListStateFilterAction enum values."""

    INCLUDE = "include"
    EXCLUDE = "exclude"
    IGNORE = "ignore"


class MinimumHealthyHostsPerZoneType:
    """MinimumHealthyHostsPerZoneType enum values."""

    HOST_COUNT = "HOST_COUNT"
    FLEET_PERCENT = "FLEET_PERCENT"


class MinimumHealthyHostsType:
    """MinimumHealthyHostsType enum values."""

    HOST_COUNT = "HOST_COUNT"
    FLEET_PERCENT = "FLEET_PERCENT"


class OutdatedInstancesStrategy:
    """OutdatedInstancesStrategy enum values."""

    UPDATE = "UPDATE"
    IGNORE = "IGNORE"


class RegistrationStatus:
    """RegistrationStatus enum values."""

    REGISTERED = "Registered"
    DEREGISTERED = "Deregistered"


class RevisionLocationType:
    """RevisionLocationType enum values."""

    S3 = "S3"
    GITHUB = "GitHub"
    STRING = "String"
    APPSPECCONTENT = "AppSpecContent"


class SortOrder:
    """SortOrder enum values."""

    ASCENDING = "ascending"
    DESCENDING = "descending"


class StopStatus:
    """StopStatus enum values."""

    PENDING = "Pending"
    SUCCEEDED = "Succeeded"


class TagFilterType:
    """TagFilterType enum values."""

    KEY_ONLY = "KEY_ONLY"
    VALUE_ONLY = "VALUE_ONLY"
    KEY_AND_VALUE = "KEY_AND_VALUE"


class TargetFilterName:
    """TargetFilterName enum values."""

    TARGETSTATUS = "TargetStatus"
    SERVERINSTANCELABEL = "ServerInstanceLabel"


class TargetLabel:
    """TargetLabel enum values."""

    BLUE = "Blue"
    GREEN = "Green"


class TargetStatus:
    """TargetStatus enum values."""

    PENDING = "Pending"
    INPROGRESS = "InProgress"
    SUCCEEDED = "Succeeded"
    FAILED = "Failed"
    SKIPPED = "Skipped"
    UNKNOWN = "Unknown"
    READY = "Ready"


class TrafficRoutingType:
    """TrafficRoutingType enum values."""

    TIMEBASEDCANARY = "TimeBasedCanary"
    TIMEBASEDLINEAR = "TimeBasedLinear"
    ALLATONCE = "AllAtOnce"


class TriggerEventType:
    """TriggerEventType enum values."""

    DEPLOYMENTSTART = "DeploymentStart"
    DEPLOYMENTSUCCESS = "DeploymentSuccess"
    DEPLOYMENTFAILURE = "DeploymentFailure"
    DEPLOYMENTSTOP = "DeploymentStop"
    DEPLOYMENTROLLBACK = "DeploymentRollback"
    DEPLOYMENTREADY = "DeploymentReady"
    INSTANCESTART = "InstanceStart"
    INSTANCESUCCESS = "InstanceSuccess"
    INSTANCEFAILURE = "InstanceFailure"
    INSTANCEREADY = "InstanceReady"


# Convenient aliases for enum values
REGISTERTIME = ApplicationRevisionSortBy.REGISTERTIME
FIRSTUSEDTIME = ApplicationRevisionSortBy.FIRSTUSEDTIME
LASTUSEDTIME = ApplicationRevisionSortBy.LASTUSEDTIME
DEPLOYMENT_FAILURE = AutoRollbackEvent.DEPLOYMENT_FAILURE
DEPLOYMENT_STOP_ON_ALARM = AutoRollbackEvent.DEPLOYMENT_STOP_ON_ALARM
DEPLOYMENT_STOP_ON_REQUEST = AutoRollbackEvent.DEPLOYMENT_STOP_ON_REQUEST
TAR = BundleType.TAR
TGZ = BundleType.TGZ
ZIP = BundleType.ZIP
YAML = BundleType.YAML
JSON = BundleType.JSON
SERVER = ComputePlatform.SERVER
LAMBDA = ComputePlatform.LAMBDA
ECS = ComputePlatform.ECS
USER = DeploymentCreator.USER
AUTOSCALING = DeploymentCreator.AUTOSCALING
CODEDEPLOYROLLBACK = DeploymentCreator.CODEDEPLOYROLLBACK
CODEDEPLOY = DeploymentCreator.CODEDEPLOY
CODEDEPLOYAUTOUPDATE = DeploymentCreator.CODEDEPLOYAUTOUPDATE
CLOUDFORMATION = DeploymentCreator.CLOUDFORMATION
CLOUDFORMATIONROLLBACK = DeploymentCreator.CLOUDFORMATIONROLLBACK
AUTOSCALINGTERMINATION = DeploymentCreator.AUTOSCALINGTERMINATION
WITH_TRAFFIC_CONTROL = DeploymentOption.WITH_TRAFFIC_CONTROL
WITHOUT_TRAFFIC_CONTROL = DeploymentOption.WITHOUT_TRAFFIC_CONTROL
CONTINUE_DEPLOYMENT = DeploymentReadyAction.CONTINUE_DEPLOYMENT
STOP_DEPLOYMENT = DeploymentReadyAction.STOP_DEPLOYMENT
CREATED = DeploymentStatus.CREATED
QUEUED = DeploymentStatus.QUEUED
INPROGRESS = DeploymentStatus.INPROGRESS
BAKING = DeploymentStatus.BAKING
SUCCEEDED = DeploymentStatus.SUCCEEDED
FAILED = DeploymentStatus.FAILED
STOPPED = DeploymentStatus.STOPPED
READY = DeploymentStatus.READY
INSTANCETARGET = DeploymentTargetType.INSTANCETARGET
LAMBDATARGET = DeploymentTargetType.LAMBDATARGET
ECSTARGET = DeploymentTargetType.ECSTARGET
CLOUDFORMATIONTARGET = DeploymentTargetType.CLOUDFORMATIONTARGET
IN_PLACE = DeploymentType.IN_PLACE
BLUE_GREEN = DeploymentType.BLUE_GREEN
READY_WAIT = DeploymentWaitType.READY_WAIT
TERMINATION_WAIT = DeploymentWaitType.TERMINATION_WAIT
KEY_ONLY = EC2TagFilterType.KEY_ONLY
VALUE_ONLY = EC2TagFilterType.VALUE_ONLY
KEY_AND_VALUE = EC2TagFilterType.KEY_AND_VALUE
AGENT_ISSUE = ErrorCode.AGENT_ISSUE
ALARM_ACTIVE = ErrorCode.ALARM_ACTIVE
APPLICATION_MISSING = ErrorCode.APPLICATION_MISSING
AUTOSCALING_VALIDATION_ERROR = ErrorCode.AUTOSCALING_VALIDATION_ERROR
AUTO_SCALING_CONFIGURATION = ErrorCode.AUTO_SCALING_CONFIGURATION
AUTO_SCALING_IAM_ROLE_PERMISSIONS = ErrorCode.AUTO_SCALING_IAM_ROLE_PERMISSIONS
CODEDEPLOY_RESOURCE_CANNOT_BE_FOUND = ErrorCode.CODEDEPLOY_RESOURCE_CANNOT_BE_FOUND
CUSTOMER_APPLICATION_UNHEALTHY = ErrorCode.CUSTOMER_APPLICATION_UNHEALTHY
DEPLOYMENT_GROUP_MISSING = ErrorCode.DEPLOYMENT_GROUP_MISSING
ECS_UPDATE_ERROR = ErrorCode.ECS_UPDATE_ERROR
ELASTIC_LOAD_BALANCING_INVALID = ErrorCode.ELASTIC_LOAD_BALANCING_INVALID
ELB_INVALID_INSTANCE = ErrorCode.ELB_INVALID_INSTANCE
HEALTH_CONSTRAINTS = ErrorCode.HEALTH_CONSTRAINTS
HEALTH_CONSTRAINTS_INVALID = ErrorCode.HEALTH_CONSTRAINTS_INVALID
HOOK_EXECUTION_FAILURE = ErrorCode.HOOK_EXECUTION_FAILURE
IAM_ROLE_MISSING = ErrorCode.IAM_ROLE_MISSING
IAM_ROLE_PERMISSIONS = ErrorCode.IAM_ROLE_PERMISSIONS
INTERNAL_ERROR = ErrorCode.INTERNAL_ERROR
INVALID_ECS_SERVICE = ErrorCode.INVALID_ECS_SERVICE
INVALID_LAMBDA_CONFIGURATION = ErrorCode.INVALID_LAMBDA_CONFIGURATION
INVALID_LAMBDA_FUNCTION = ErrorCode.INVALID_LAMBDA_FUNCTION
INVALID_REVISION = ErrorCode.INVALID_REVISION
MANUAL_STOP = ErrorCode.MANUAL_STOP
MISSING_BLUE_GREEN_DEPLOYMENT_CONFIGURATION = ErrorCode.MISSING_BLUE_GREEN_DEPLOYMENT_CONFIGURATION
MISSING_ELB_INFORMATION = ErrorCode.MISSING_ELB_INFORMATION
MISSING_GITHUB_TOKEN = ErrorCode.MISSING_GITHUB_TOKEN
NO_EC2_SUBSCRIPTION = ErrorCode.NO_EC2_SUBSCRIPTION
NO_INSTANCES = ErrorCode.NO_INSTANCES
OVER_MAX_INSTANCES = ErrorCode.OVER_MAX_INSTANCES
RESOURCE_LIMIT_EXCEEDED = ErrorCode.RESOURCE_LIMIT_EXCEEDED
REVISION_MISSING = ErrorCode.REVISION_MISSING
THROTTLED = ErrorCode.THROTTLED
TIMEOUT = ErrorCode.TIMEOUT
CLOUDFORMATION_STACK_FAILURE = ErrorCode.CLOUDFORMATION_STACK_FAILURE
DISALLOW = FileExistsBehavior.DISALLOW
OVERWRITE = FileExistsBehavior.OVERWRITE
RETAIN = FileExistsBehavior.RETAIN
DISCOVER_EXISTING = GreenFleetProvisioningAction.DISCOVER_EXISTING
COPY_AUTO_SCALING_GROUP = GreenFleetProvisioningAction.COPY_AUTO_SCALING_GROUP
TERMINATE = InstanceAction.TERMINATE
KEEP_ALIVE = InstanceAction.KEEP_ALIVE
PENDING = InstanceStatus.PENDING
INPROGRESS = InstanceStatus.INPROGRESS
SUCCEEDED = InstanceStatus.SUCCEEDED
FAILED = InstanceStatus.FAILED
SKIPPED = InstanceStatus.SKIPPED
UNKNOWN = InstanceStatus.UNKNOWN
READY = InstanceStatus.READY
BLUE = InstanceType.BLUE
GREEN = InstanceType.GREEN
SUCCESS = LifecycleErrorCode.SUCCESS
SCRIPTMISSING = LifecycleErrorCode.SCRIPTMISSING
SCRIPTNOTEXECUTABLE = LifecycleErrorCode.SCRIPTNOTEXECUTABLE
SCRIPTTIMEDOUT = LifecycleErrorCode.SCRIPTTIMEDOUT
SCRIPTFAILED = LifecycleErrorCode.SCRIPTFAILED
UNKNOWNERROR = LifecycleErrorCode.UNKNOWNERROR
PENDING = LifecycleEventStatus.PENDING
INPROGRESS = LifecycleEventStatus.INPROGRESS
SUCCEEDED = LifecycleEventStatus.SUCCEEDED
FAILED = LifecycleEventStatus.FAILED
SKIPPED = LifecycleEventStatus.SKIPPED
UNKNOWN = LifecycleEventStatus.UNKNOWN
INCLUDE = ListStateFilterAction.INCLUDE
EXCLUDE = ListStateFilterAction.EXCLUDE
IGNORE = ListStateFilterAction.IGNORE
HOST_COUNT = MinimumHealthyHostsPerZoneType.HOST_COUNT
FLEET_PERCENT = MinimumHealthyHostsPerZoneType.FLEET_PERCENT
HOST_COUNT = MinimumHealthyHostsType.HOST_COUNT
FLEET_PERCENT = MinimumHealthyHostsType.FLEET_PERCENT
UPDATE = OutdatedInstancesStrategy.UPDATE
IGNORE = OutdatedInstancesStrategy.IGNORE
REGISTERED = RegistrationStatus.REGISTERED
DEREGISTERED = RegistrationStatus.DEREGISTERED
S3 = RevisionLocationType.S3
GITHUB = RevisionLocationType.GITHUB
STRING = RevisionLocationType.STRING
APPSPECCONTENT = RevisionLocationType.APPSPECCONTENT
ASCENDING = SortOrder.ASCENDING
DESCENDING = SortOrder.DESCENDING
PENDING = StopStatus.PENDING
SUCCEEDED = StopStatus.SUCCEEDED
KEY_ONLY = TagFilterType.KEY_ONLY
VALUE_ONLY = TagFilterType.VALUE_ONLY
KEY_AND_VALUE = TagFilterType.KEY_AND_VALUE
TARGETSTATUS = TargetFilterName.TARGETSTATUS
SERVERINSTANCELABEL = TargetFilterName.SERVERINSTANCELABEL
BLUE = TargetLabel.BLUE
GREEN = TargetLabel.GREEN
PENDING = TargetStatus.PENDING
INPROGRESS = TargetStatus.INPROGRESS
SUCCEEDED = TargetStatus.SUCCEEDED
FAILED = TargetStatus.FAILED
SKIPPED = TargetStatus.SKIPPED
UNKNOWN = TargetStatus.UNKNOWN
READY = TargetStatus.READY
TIMEBASEDCANARY = TrafficRoutingType.TIMEBASEDCANARY
TIMEBASEDLINEAR = TrafficRoutingType.TIMEBASEDLINEAR
ALLATONCE = TrafficRoutingType.ALLATONCE
DEPLOYMENTSTART = TriggerEventType.DEPLOYMENTSTART
DEPLOYMENTSUCCESS = TriggerEventType.DEPLOYMENTSUCCESS
DEPLOYMENTFAILURE = TriggerEventType.DEPLOYMENTFAILURE
DEPLOYMENTSTOP = TriggerEventType.DEPLOYMENTSTOP
DEPLOYMENTROLLBACK = TriggerEventType.DEPLOYMENTROLLBACK
DEPLOYMENTREADY = TriggerEventType.DEPLOYMENTREADY
INSTANCESTART = TriggerEventType.INSTANCESTART
INSTANCESUCCESS = TriggerEventType.INSTANCESUCCESS
INSTANCEFAILURE = TriggerEventType.INSTANCEFAILURE
INSTANCEREADY = TriggerEventType.INSTANCEREADY


@dataclass
class Application(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-coded"""

    resource_type: ClassVar[str] = "AWS::CodeDeploy::Application"
    _property_mappings: ClassVar[dict[str, str]] = {
        "application_name": "ApplicationName",
        "compute_platform": "ComputePlatform",
        "tags": "Tags",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    application_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    compute_platform: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None



@dataclass
class MinimumHealthyHosts:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "type_": "Type",
        "value": "Value",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class MinimumHealthyHostsPerZone:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "type_": "Type",
        "value": "Value",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TimeBasedCanary:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "canary_percentage": "CanaryPercentage",
        "canary_interval": "CanaryInterval",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    canary_percentage: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    canary_interval: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TimeBasedLinear:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "linear_interval": "LinearInterval",
        "linear_percentage": "LinearPercentage",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    linear_interval: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    linear_percentage: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TrafficRoutingConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "type_": "Type",
        "time_based_linear": "TimeBasedLinear",
        "time_based_canary": "TimeBasedCanary",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    time_based_linear: Optional[TimeBasedLinear] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    time_based_canary: Optional[TimeBasedCanary] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class ZonalConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "monitor_duration_in_seconds": "MonitorDurationInSeconds",
        "minimum_healthy_hosts_per_zone": "MinimumHealthyHostsPerZone",
        "first_zone_monitor_duration_in_seconds": "FirstZoneMonitorDurationInSeconds",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    monitor_duration_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    minimum_healthy_hosts_per_zone: Optional[MinimumHealthyHostsPerZone] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    first_zone_monitor_duration_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class DeploymentConfig(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-coded"""

    resource_type: ClassVar[str] = "AWS::CodeDeploy::DeploymentConfig"
    _property_mappings: ClassVar[dict[str, str]] = {
        "compute_platform": "ComputePlatform",
        "zonal_config": "ZonalConfig",
        "deployment_config_name": "DeploymentConfigName",
        "traffic_routing_config": "TrafficRoutingConfig",
        "minimum_healthy_hosts": "MinimumHealthyHosts",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    compute_platform: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    zonal_config: Optional[ZonalConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    deployment_config_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    traffic_routing_config: Optional[TrafficRoutingConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    minimum_healthy_hosts: Optional[MinimumHealthyHosts] = None



@dataclass
class Alarm:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "name": "Name",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class AlarmConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "alarms": "Alarms",
        "enabled": "Enabled",
        "ignore_poll_alarm_failure": "IgnorePollAlarmFailure",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    alarms: Optional[list[Alarm]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ignore_poll_alarm_failure: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class AutoRollbackConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "enabled": "Enabled",
        "events": "Events",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    events: Optional[Union[list[str], Ref]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class BlueGreenDeploymentConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "deployment_ready_option": "DeploymentReadyOption",
        "green_fleet_provisioning_option": "GreenFleetProvisioningOption",
        "terminate_blue_instances_on_deployment_success": "TerminateBlueInstancesOnDeploymentSuccess",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    deployment_ready_option: Optional[DeploymentReadyOption] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    green_fleet_provisioning_option: Optional[GreenFleetProvisioningOption] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    terminate_blue_instances_on_deployment_success: Optional[BlueInstanceTerminationOption] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class BlueInstanceTerminationOption:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "action": "Action",
        "termination_wait_time_in_minutes": "TerminationWaitTimeInMinutes",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    action: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    termination_wait_time_in_minutes: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class Deployment:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "description": "Description",
        "ignore_application_stop_failures": "IgnoreApplicationStopFailures",
        "revision": "Revision",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ignore_application_stop_failures: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    revision: Optional[RevisionLocation] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class DeploymentReadyOption:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "action_on_timeout": "ActionOnTimeout",
        "wait_time_in_minutes": "WaitTimeInMinutes",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    action_on_timeout: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    wait_time_in_minutes: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class DeploymentStyle:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "deployment_option": "DeploymentOption",
        "deployment_type": "DeploymentType",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    deployment_option: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    deployment_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class EC2TagFilter:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "key": "Key",
        "type_": "Type",
        "value": "Value",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, EC2TagFilterType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class EC2TagSet:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "ec2_tag_set_list": "Ec2TagSetList",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ec2_tag_set_list: Optional[list[EC2TagSetListObject]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class EC2TagSetListObject:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "ec2_tag_group": "Ec2TagGroup",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ec2_tag_group: Optional[list[EC2TagFilter]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class ECSService:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "cluster_name": "ClusterName",
        "service_name": "ServiceName",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cluster_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    service_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class ELBInfo:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "name": "Name",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class GitHubLocation:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "commit_id": "CommitId",
        "repository": "Repository",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    commit_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    repository: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class GreenFleetProvisioningOption:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "action": "Action",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    action: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class LoadBalancerInfo:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "elb_info_list": "ElbInfoList",
        "target_group_info_list": "TargetGroupInfoList",
        "target_group_pair_info_list": "TargetGroupPairInfoList",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    elb_info_list: Optional[list[ELBInfo]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_group_info_list: Optional[list[TargetGroupInfo]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_group_pair_info_list: Optional[list[TargetGroupPairInfo]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class OnPremisesTagSet:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "on_premises_tag_set_list": "OnPremisesTagSetList",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_premises_tag_set_list: Optional[list[OnPremisesTagSetListObject]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class OnPremisesTagSetListObject:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "on_premises_tag_group": "OnPremisesTagGroup",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_premises_tag_group: Optional[list[TagFilter]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class RevisionLocation:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "git_hub_location": "GitHubLocation",
        "revision_type": "RevisionType",
        "s3_location": "S3Location",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    git_hub_location: Optional[GitHubLocation] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    revision_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_location: Optional[S3Location] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class S3Location:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "bucket": "Bucket",
        "bundle_type": "BundleType",
        "e_tag": "ETag",
        "key": "Key",
        "version": "Version",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bucket: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bundle_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    e_tag: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    version: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TagFilter:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "key": "Key",
        "type_": "Type",
        "value": "Value",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, TagFilterType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TargetGroupInfo:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "name": "Name",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TargetGroupPairInfo:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "prod_traffic_route": "ProdTrafficRoute",
        "target_groups": "TargetGroups",
        "test_traffic_route": "TestTrafficRoute",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    prod_traffic_route: Optional[TrafficRoute] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_groups: Optional[list[TargetGroupInfo]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    test_traffic_route: Optional[TrafficRoute] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TrafficRoute:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "listener_arns": "ListenerArns",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    listener_arns: Optional[Union[list[str], Ref]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TriggerConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "trigger_events": "TriggerEvents",
        "trigger_name": "TriggerName",
        "trigger_target_arn": "TriggerTargetArn",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    trigger_events: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    trigger_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    trigger_target_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class DeploymentGroup(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-coded"""

    resource_type: ClassVar[str] = "AWS::CodeDeploy::DeploymentGroup"
    _property_mappings: ClassVar[dict[str, str]] = {
        "alarm_configuration": "AlarmConfiguration",
        "application_name": "ApplicationName",
        "auto_rollback_configuration": "AutoRollbackConfiguration",
        "auto_scaling_groups": "AutoScalingGroups",
        "blue_green_deployment_configuration": "BlueGreenDeploymentConfiguration",
        "deployment": "Deployment",
        "deployment_config_name": "DeploymentConfigName",
        "deployment_group_name": "DeploymentGroupName",
        "deployment_style": "DeploymentStyle",
        "ecs_services": "ECSServices",
        "ec2_tag_filters": "Ec2TagFilters",
        "ec2_tag_set": "Ec2TagSet",
        "load_balancer_info": "LoadBalancerInfo",
        "on_premises_instance_tag_filters": "OnPremisesInstanceTagFilters",
        "on_premises_tag_set": "OnPremisesTagSet",
        "outdated_instances_strategy": "OutdatedInstancesStrategy",
        "service_role_arn": "ServiceRoleArn",
        "tags": "Tags",
        "termination_hook_enabled": "TerminationHookEnabled",
        "trigger_configurations": "TriggerConfigurations",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    alarm_configuration: Optional[AlarmConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    application_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auto_rollback_configuration: Optional[AutoRollbackConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auto_scaling_groups: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    blue_green_deployment_configuration: Optional[BlueGreenDeploymentConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    deployment: Optional[Deployment] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    deployment_config_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    deployment_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    deployment_style: Optional[DeploymentStyle] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ecs_services: Optional[list[ECSService]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ec2_tag_filters: Optional[list[EC2TagFilter]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ec2_tag_set: Optional[EC2TagSet] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    load_balancer_info: Optional[LoadBalancerInfo] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    on_premises_instance_tag_filters: Optional[list[TagFilter]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    on_premises_tag_set: Optional[OnPremisesTagSet] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    outdated_instances_strategy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    service_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    termination_hook_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    trigger_configurations: Optional[list[TriggerConfig]] = None



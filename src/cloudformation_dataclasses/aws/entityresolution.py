"""
AWS CloudFormation EntityResolution Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 21:37:42

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service EntityResolution
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class AttributeMatchingModel:
    """AttributeMatchingModel enum values."""

    ONE_TO_ONE = "ONE_TO_ONE"
    MANY_TO_MANY = "MANY_TO_MANY"


class DeleteUniqueIdErrorType:
    """DeleteUniqueIdErrorType enum values."""

    SERVICE_ERROR = "SERVICE_ERROR"
    VALIDATION_ERROR = "VALIDATION_ERROR"


class DeleteUniqueIdStatus:
    """DeleteUniqueIdStatus enum values."""

    COMPLETED = "COMPLETED"
    ACCEPTED = "ACCEPTED"


class IdMappingIncrementalRunType:
    """IdMappingIncrementalRunType enum values."""

    ON_DEMAND = "ON_DEMAND"


class IdMappingType:
    """IdMappingType enum values."""

    PROVIDER = "PROVIDER"
    RULE_BASED = "RULE_BASED"


class IdMappingWorkflowRuleDefinitionType:
    """IdMappingWorkflowRuleDefinitionType enum values."""

    SOURCE = "SOURCE"
    TARGET = "TARGET"


class IdNamespaceType:
    """IdNamespaceType enum values."""

    SOURCE = "SOURCE"
    TARGET = "TARGET"


class IncrementalRunType:
    """IncrementalRunType enum values."""

    IMMEDIATE = "IMMEDIATE"


class JobStatus:
    """JobStatus enum values."""

    RUNNING = "RUNNING"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    QUEUED = "QUEUED"


class JobType:
    """JobType enum values."""

    BATCH = "BATCH"
    INCREMENTAL = "INCREMENTAL"
    DELETE_ONLY = "DELETE_ONLY"


class MatchPurpose:
    """MatchPurpose enum values."""

    IDENTIFIER_GENERATION = "IDENTIFIER_GENERATION"
    INDEXING = "INDEXING"


class ProcessingType:
    """ProcessingType enum values."""

    CONSISTENT = "CONSISTENT"
    EVENTUAL = "EVENTUAL"
    EVENTUAL_NO_LOOKUP = "EVENTUAL_NO_LOOKUP"


class RecordMatchingModel:
    """RecordMatchingModel enum values."""

    ONE_SOURCE_TO_ONE_TARGET = "ONE_SOURCE_TO_ONE_TARGET"
    MANY_SOURCE_TO_ONE_TARGET = "MANY_SOURCE_TO_ONE_TARGET"


class ResolutionType:
    """ResolutionType enum values."""

    RULE_MATCHING = "RULE_MATCHING"
    ML_MATCHING = "ML_MATCHING"
    PROVIDER = "PROVIDER"


class SchemaAttributeType:
    """SchemaAttributeType enum values."""

    NAME = "NAME"
    NAME_FIRST = "NAME_FIRST"
    NAME_MIDDLE = "NAME_MIDDLE"
    NAME_LAST = "NAME_LAST"
    ADDRESS = "ADDRESS"
    ADDRESS_STREET1 = "ADDRESS_STREET1"
    ADDRESS_STREET2 = "ADDRESS_STREET2"
    ADDRESS_STREET3 = "ADDRESS_STREET3"
    ADDRESS_CITY = "ADDRESS_CITY"
    ADDRESS_STATE = "ADDRESS_STATE"
    ADDRESS_COUNTRY = "ADDRESS_COUNTRY"
    ADDRESS_POSTALCODE = "ADDRESS_POSTALCODE"
    PHONE = "PHONE"
    PHONE_NUMBER = "PHONE_NUMBER"
    PHONE_COUNTRYCODE = "PHONE_COUNTRYCODE"
    EMAIL_ADDRESS = "EMAIL_ADDRESS"
    UNIQUE_ID = "UNIQUE_ID"
    DATE = "DATE"
    STRING = "STRING"
    PROVIDER_ID = "PROVIDER_ID"
    IPV4 = "IPV4"
    IPV6 = "IPV6"
    MAID = "MAID"


class ServiceType:
    """ServiceType enum values."""

    ASSIGNMENT = "ASSIGNMENT"
    ID_MAPPING = "ID_MAPPING"


class StatementEffect:
    """StatementEffect enum values."""

    ALLOW = "Allow"
    DENY = "Deny"


# Convenient aliases for enum values
ONE_TO_ONE = AttributeMatchingModel.ONE_TO_ONE
MANY_TO_MANY = AttributeMatchingModel.MANY_TO_MANY
SERVICE_ERROR = DeleteUniqueIdErrorType.SERVICE_ERROR
VALIDATION_ERROR = DeleteUniqueIdErrorType.VALIDATION_ERROR
COMPLETED = DeleteUniqueIdStatus.COMPLETED
ACCEPTED = DeleteUniqueIdStatus.ACCEPTED
ON_DEMAND = IdMappingIncrementalRunType.ON_DEMAND
PROVIDER = IdMappingType.PROVIDER
RULE_BASED = IdMappingType.RULE_BASED
SOURCE = IdMappingWorkflowRuleDefinitionType.SOURCE
TARGET = IdMappingWorkflowRuleDefinitionType.TARGET
SOURCE = IdNamespaceType.SOURCE
TARGET = IdNamespaceType.TARGET
IMMEDIATE = IncrementalRunType.IMMEDIATE
RUNNING = JobStatus.RUNNING
SUCCEEDED = JobStatus.SUCCEEDED
FAILED = JobStatus.FAILED
QUEUED = JobStatus.QUEUED
BATCH = JobType.BATCH
INCREMENTAL = JobType.INCREMENTAL
DELETE_ONLY = JobType.DELETE_ONLY
IDENTIFIER_GENERATION = MatchPurpose.IDENTIFIER_GENERATION
INDEXING = MatchPurpose.INDEXING
CONSISTENT = ProcessingType.CONSISTENT
EVENTUAL = ProcessingType.EVENTUAL
EVENTUAL_NO_LOOKUP = ProcessingType.EVENTUAL_NO_LOOKUP
ONE_SOURCE_TO_ONE_TARGET = RecordMatchingModel.ONE_SOURCE_TO_ONE_TARGET
MANY_SOURCE_TO_ONE_TARGET = RecordMatchingModel.MANY_SOURCE_TO_ONE_TARGET
RULE_MATCHING = ResolutionType.RULE_MATCHING
ML_MATCHING = ResolutionType.ML_MATCHING
PROVIDER = ResolutionType.PROVIDER
NAME = SchemaAttributeType.NAME
NAME_FIRST = SchemaAttributeType.NAME_FIRST
NAME_MIDDLE = SchemaAttributeType.NAME_MIDDLE
NAME_LAST = SchemaAttributeType.NAME_LAST
ADDRESS = SchemaAttributeType.ADDRESS
ADDRESS_STREET1 = SchemaAttributeType.ADDRESS_STREET1
ADDRESS_STREET2 = SchemaAttributeType.ADDRESS_STREET2
ADDRESS_STREET3 = SchemaAttributeType.ADDRESS_STREET3
ADDRESS_CITY = SchemaAttributeType.ADDRESS_CITY
ADDRESS_STATE = SchemaAttributeType.ADDRESS_STATE
ADDRESS_COUNTRY = SchemaAttributeType.ADDRESS_COUNTRY
ADDRESS_POSTALCODE = SchemaAttributeType.ADDRESS_POSTALCODE
PHONE = SchemaAttributeType.PHONE
PHONE_NUMBER = SchemaAttributeType.PHONE_NUMBER
PHONE_COUNTRYCODE = SchemaAttributeType.PHONE_COUNTRYCODE
EMAIL_ADDRESS = SchemaAttributeType.EMAIL_ADDRESS
UNIQUE_ID = SchemaAttributeType.UNIQUE_ID
DATE = SchemaAttributeType.DATE
STRING = SchemaAttributeType.STRING
PROVIDER_ID = SchemaAttributeType.PROVIDER_ID
IPV4 = SchemaAttributeType.IPV4
IPV6 = SchemaAttributeType.IPV6
MAID = SchemaAttributeType.MAID
ASSIGNMENT = ServiceType.ASSIGNMENT
ID_MAPPING = ServiceType.ID_MAPPING
ALLOW = StatementEffect.ALLOW
DENY = StatementEffect.DENY


@dataclass
class IdMappingIncrementalRunConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ent"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "incremental_run_type": "IncrementalRunType",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    incremental_run_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class IdMappingRuleBasedProperties:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ent"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "attribute_matching_model": "AttributeMatchingModel",
        "rule_definition_type": "RuleDefinitionType",
        "rules": "Rules",
        "record_matching_model": "RecordMatchingModel",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    attribute_matching_model: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rule_definition_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rules: Optional[list[Rule]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    record_matching_model: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class IdMappingTechniques:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ent"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "rule_based_properties": "RuleBasedProperties",
        "provider_properties": "ProviderProperties",
        "id_mapping_type": "IdMappingType",
        "normalization_version": "NormalizationVersion",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rule_based_properties: Optional[IdMappingRuleBasedProperties] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    provider_properties: Optional[ProviderProperties] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    id_mapping_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    normalization_version: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class IdMappingWorkflowInputSource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ent"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "type_": "Type",
        "input_source_arn": "InputSourceARN",
        "schema_arn": "SchemaArn",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    input_source_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    schema_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class IdMappingWorkflowOutputSource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ent"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "kms_arn": "KMSArn",
        "output_s3_path": "OutputS3Path",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    output_s3_path: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class IntermediateSourceConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ent"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "intermediate_s3_path": "IntermediateS3Path",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    intermediate_s3_path: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class ProviderProperties:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ent"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "intermediate_source_configuration": "IntermediateSourceConfiguration",
        "provider_service_arn": "ProviderServiceArn",
        "provider_configuration": "ProviderConfiguration",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    intermediate_source_configuration: Optional[IntermediateSourceConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    provider_service_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    provider_configuration: Optional[dict[str, str]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class Rule:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ent"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "matching_keys": "MatchingKeys",
        "rule_name": "RuleName",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    matching_keys: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rule_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class IdMappingWorkflow(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-entit"""

    resource_type: ClassVar[str] = "AWS::EntityResolution::IdMappingWorkflow"
    _property_mappings: ClassVar[dict[str, str]] = {
        "description": "Description",
        "input_source_config": "InputSourceConfig",
        "id_mapping_techniques": "IdMappingTechniques",
        "workflow_name": "WorkflowName",
        "output_source_config": "OutputSourceConfig",
        "id_mapping_incremental_run_config": "IdMappingIncrementalRunConfig",
        "role_arn": "RoleArn",
        "tags": "Tags",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    input_source_config: Optional[list[IdMappingWorkflowInputSource]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    id_mapping_techniques: Optional[IdMappingTechniques] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    workflow_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    output_source_config: Optional[list[IdMappingWorkflowOutputSource]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    id_mapping_incremental_run_config: Optional[IdMappingIncrementalRunConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    @property
    def attr_created_at(self) -> GetAtt:
        """Get the CreatedAt attribute."""
        return self.get_att("CreatedAt")

    @property
    def attr_workflow_arn(self) -> GetAtt:
        """Get the WorkflowArn attribute."""
        return self.get_att("WorkflowArn")

    @property
    def attr_updated_at(self) -> GetAtt:
        """Get the UpdatedAt attribute."""
        return self.get_att("UpdatedAt")




@dataclass
class IdNamespaceIdMappingWorkflowProperties:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ent"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "rule_based_properties": "RuleBasedProperties",
        "provider_properties": "ProviderProperties",
        "id_mapping_type": "IdMappingType",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rule_based_properties: Optional[NamespaceRuleBasedProperties] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    provider_properties: Optional[NamespaceProviderProperties] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    id_mapping_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class IdNamespaceInputSource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ent"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "input_source_arn": "InputSourceARN",
        "schema_name": "SchemaName",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    input_source_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    schema_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class NamespaceProviderProperties:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ent"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "provider_service_arn": "ProviderServiceArn",
        "provider_configuration": "ProviderConfiguration",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    provider_service_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    provider_configuration: Optional[dict[str, str]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class NamespaceRuleBasedProperties:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ent"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "attribute_matching_model": "AttributeMatchingModel",
        "rule_definition_types": "RuleDefinitionTypes",
        "record_matching_models": "RecordMatchingModels",
        "rules": "Rules",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    attribute_matching_model: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rule_definition_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    record_matching_models: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rules: Optional[list[Rule]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class Rule:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ent"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "matching_keys": "MatchingKeys",
        "rule_name": "RuleName",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    matching_keys: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rule_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class IdNamespace(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-entit"""

    resource_type: ClassVar[str] = "AWS::EntityResolution::IdNamespace"
    _property_mappings: ClassVar[dict[str, str]] = {
        "id_namespace_name": "IdNamespaceName",
        "type_": "Type",
        "description": "Description",
        "input_source_config": "InputSourceConfig",
        "id_mapping_workflow_properties": "IdMappingWorkflowProperties",
        "role_arn": "RoleArn",
        "tags": "Tags",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    id_namespace_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    input_source_config: Optional[list[IdNamespaceInputSource]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    id_mapping_workflow_properties: Optional[list[IdNamespaceIdMappingWorkflowProperties]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    @property
    def attr_created_at(self) -> GetAtt:
        """Get the CreatedAt attribute."""
        return self.get_att("CreatedAt")

    @property
    def attr_updated_at(self) -> GetAtt:
        """Get the UpdatedAt attribute."""
        return self.get_att("UpdatedAt")

    @property
    def attr_id_namespace_arn(self) -> GetAtt:
        """Get the IdNamespaceArn attribute."""
        return self.get_att("IdNamespaceArn")




@dataclass
class IncrementalRunConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ent"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "incremental_run_type": "IncrementalRunType",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    incremental_run_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class InputSource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ent"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "apply_normalization": "ApplyNormalization",
        "input_source_arn": "InputSourceARN",
        "schema_arn": "SchemaArn",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    apply_normalization: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    input_source_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    schema_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class IntermediateSourceConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ent"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "intermediate_s3_path": "IntermediateS3Path",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    intermediate_s3_path: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class OutputAttribute:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ent"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "hashed": "Hashed",
        "name": "Name",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hashed: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class OutputSource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ent"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "kms_arn": "KMSArn",
        "output_s3_path": "OutputS3Path",
        "output": "Output",
        "apply_normalization": "ApplyNormalization",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    output_s3_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    output: Optional[list[OutputAttribute]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    apply_normalization: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class ProviderProperties:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ent"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "intermediate_source_configuration": "IntermediateSourceConfiguration",
        "provider_service_arn": "ProviderServiceArn",
        "provider_configuration": "ProviderConfiguration",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    intermediate_source_configuration: Optional[IntermediateSourceConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    provider_service_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    provider_configuration: Optional[dict[str, str]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class ResolutionTechniques:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ent"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "rule_based_properties": "RuleBasedProperties",
        "provider_properties": "ProviderProperties",
        "resolution_type": "ResolutionType",
        "rule_condition_properties": "RuleConditionProperties",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rule_based_properties: Optional[RuleBasedProperties] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    provider_properties: Optional[ProviderProperties] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resolution_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rule_condition_properties: Optional[RuleConditionProperties] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class Rule:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ent"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "matching_keys": "MatchingKeys",
        "rule_name": "RuleName",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    matching_keys: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rule_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class RuleBasedProperties:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ent"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "attribute_matching_model": "AttributeMatchingModel",
        "match_purpose": "MatchPurpose",
        "rules": "Rules",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    attribute_matching_model: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    match_purpose: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rules: Optional[list[Rule]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class RuleCondition:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ent"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "condition": "Condition",
        "rule_name": "RuleName",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    condition: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rule_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class RuleConditionProperties:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ent"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "rules": "Rules",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rules: Optional[list[RuleCondition]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class MatchingWorkflow(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-entit"""

    resource_type: ClassVar[str] = "AWS::EntityResolution::MatchingWorkflow"
    _property_mappings: ClassVar[dict[str, str]] = {
        "resolution_techniques": "ResolutionTechniques",
        "description": "Description",
        "input_source_config": "InputSourceConfig",
        "workflow_name": "WorkflowName",
        "incremental_run_config": "IncrementalRunConfig",
        "output_source_config": "OutputSourceConfig",
        "role_arn": "RoleArn",
        "tags": "Tags",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resolution_techniques: Optional[ResolutionTechniques] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    input_source_config: Optional[list[InputSource]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    workflow_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    incremental_run_config: Optional[IncrementalRunConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    output_source_config: Optional[list[OutputSource]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    @property
    def attr_created_at(self) -> GetAtt:
        """Get the CreatedAt attribute."""
        return self.get_att("CreatedAt")

    @property
    def attr_workflow_arn(self) -> GetAtt:
        """Get the WorkflowArn attribute."""
        return self.get_att("WorkflowArn")

    @property
    def attr_updated_at(self) -> GetAtt:
        """Get the UpdatedAt attribute."""
        return self.get_att("UpdatedAt")




@dataclass
class PolicyStatement(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-entit"""

    resource_type: ClassVar[str] = "AWS::EntityResolution::PolicyStatement"
    _property_mappings: ClassVar[dict[str, str]] = {
        "condition": "Condition",
        "action": "Action",
        "statement_id": "StatementId",
        "effect": "Effect",
        "arn": "Arn",
        "principal": "Principal",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    condition: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    action: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    statement_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    effect: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    principal: Optional[Union[list[str], Ref]] = None



@dataclass
class SchemaInputAttribute:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ent"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "group_name": "GroupName",
        "type_": "Type",
        "sub_type": "SubType",
        "hashed": "Hashed",
        "match_key": "MatchKey",
        "field_name": "FieldName",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    sub_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hashed: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    match_key: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    field_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class SchemaMapping(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-entit"""

    resource_type: ClassVar[str] = "AWS::EntityResolution::SchemaMapping"
    _property_mappings: ClassVar[dict[str, str]] = {
        "description": "Description",
        "mapped_input_fields": "MappedInputFields",
        "schema_name": "SchemaName",
        "tags": "Tags",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    mapped_input_fields: Optional[list[SchemaInputAttribute]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    schema_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    @property
    def attr_created_at(self) -> GetAtt:
        """Get the CreatedAt attribute."""
        return self.get_att("CreatedAt")

    @property
    def attr_has_workflows(self) -> GetAtt:
        """Get the HasWorkflows attribute."""
        return self.get_att("HasWorkflows")

    @property
    def attr_updated_at(self) -> GetAtt:
        """Get the UpdatedAt attribute."""
        return self.get_att("UpdatedAt")

    @property
    def attr_schema_arn(self) -> GetAtt:
        """Get the SchemaArn attribute."""
        return self.get_att("SchemaArn")




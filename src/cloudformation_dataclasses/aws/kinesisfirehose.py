"""
AWS CloudFormation KinesisFirehose Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 21:37:49

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service KinesisFirehose
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class AmazonOpenSearchServerlessS3BackupMode:
    """AmazonOpenSearchServerlessS3BackupMode enum values."""

    FAILEDDOCUMENTSONLY = "FailedDocumentsOnly"
    ALLDOCUMENTS = "AllDocuments"


class AmazonopensearchserviceIndexRotationPeriod:
    """AmazonopensearchserviceIndexRotationPeriod enum values."""

    NOROTATION = "NoRotation"
    ONEHOUR = "OneHour"
    ONEDAY = "OneDay"
    ONEWEEK = "OneWeek"
    ONEMONTH = "OneMonth"


class AmazonopensearchserviceS3BackupMode:
    """AmazonopensearchserviceS3BackupMode enum values."""

    FAILEDDOCUMENTSONLY = "FailedDocumentsOnly"
    ALLDOCUMENTS = "AllDocuments"


class CompressionFormat:
    """CompressionFormat enum values."""

    UNCOMPRESSED = "UNCOMPRESSED"
    GZIP = "GZIP"
    ZIP = "ZIP"
    SNAPPY = "Snappy"
    HADOOP_SNAPPY = "HADOOP_SNAPPY"


class Connectivity:
    """Connectivity enum values."""

    PUBLIC = "PUBLIC"
    PRIVATE = "PRIVATE"


class ContentEncoding:
    """ContentEncoding enum values."""

    NONE = "NONE"
    GZIP = "GZIP"


class DatabaseType:
    """DatabaseType enum values."""

    MYSQL = "MySQL"
    POSTGRESQL = "PostgreSQL"


class DefaultDocumentIdFormat:
    """DefaultDocumentIdFormat enum values."""

    FIREHOSE_DEFAULT = "FIREHOSE_DEFAULT"
    NO_DOCUMENT_ID = "NO_DOCUMENT_ID"


class DeliveryStreamEncryptionStatus:
    """DeliveryStreamEncryptionStatus enum values."""

    ENABLED = "ENABLED"
    ENABLING = "ENABLING"
    ENABLING_FAILED = "ENABLING_FAILED"
    DISABLED = "DISABLED"
    DISABLING = "DISABLING"
    DISABLING_FAILED = "DISABLING_FAILED"


class DeliveryStreamFailureType:
    """DeliveryStreamFailureType enum values."""

    VPC_ENDPOINT_SERVICE_NAME_NOT_FOUND = "VPC_ENDPOINT_SERVICE_NAME_NOT_FOUND"
    VPC_INTERFACE_ENDPOINT_SERVICE_ACCESS_DENIED = "VPC_INTERFACE_ENDPOINT_SERVICE_ACCESS_DENIED"
    RETIRE_KMS_GRANT_FAILED = "RETIRE_KMS_GRANT_FAILED"
    CREATE_KMS_GRANT_FAILED = "CREATE_KMS_GRANT_FAILED"
    KMS_ACCESS_DENIED = "KMS_ACCESS_DENIED"
    DISABLED_KMS_KEY = "DISABLED_KMS_KEY"
    INVALID_KMS_KEY = "INVALID_KMS_KEY"
    KMS_KEY_NOT_FOUND = "KMS_KEY_NOT_FOUND"
    KMS_OPT_IN_REQUIRED = "KMS_OPT_IN_REQUIRED"
    CREATE_ENI_FAILED = "CREATE_ENI_FAILED"
    DELETE_ENI_FAILED = "DELETE_ENI_FAILED"
    SUBNET_NOT_FOUND = "SUBNET_NOT_FOUND"
    SECURITY_GROUP_NOT_FOUND = "SECURITY_GROUP_NOT_FOUND"
    ENI_ACCESS_DENIED = "ENI_ACCESS_DENIED"
    SUBNET_ACCESS_DENIED = "SUBNET_ACCESS_DENIED"
    SECURITY_GROUP_ACCESS_DENIED = "SECURITY_GROUP_ACCESS_DENIED"
    UNKNOWN_ERROR = "UNKNOWN_ERROR"


class DeliveryStreamStatus:
    """DeliveryStreamStatus enum values."""

    CREATING = "CREATING"
    CREATING_FAILED = "CREATING_FAILED"
    DELETING = "DELETING"
    DELETING_FAILED = "DELETING_FAILED"
    ACTIVE = "ACTIVE"


class DeliveryStreamType:
    """DeliveryStreamType enum values."""

    DIRECTPUT = "DirectPut"
    KINESISSTREAMASSOURCE = "KinesisStreamAsSource"
    MSKASSOURCE = "MSKAsSource"
    DATABASEASSOURCE = "DatabaseAsSource"


class ElasticsearchIndexRotationPeriod:
    """ElasticsearchIndexRotationPeriod enum values."""

    NOROTATION = "NoRotation"
    ONEHOUR = "OneHour"
    ONEDAY = "OneDay"
    ONEWEEK = "OneWeek"
    ONEMONTH = "OneMonth"


class ElasticsearchS3BackupMode:
    """ElasticsearchS3BackupMode enum values."""

    FAILEDDOCUMENTSONLY = "FailedDocumentsOnly"
    ALLDOCUMENTS = "AllDocuments"


class HECEndpointType:
    """HECEndpointType enum values."""

    RAW = "Raw"
    EVENT = "Event"


class HttpEndpointS3BackupMode:
    """HttpEndpointS3BackupMode enum values."""

    FAILEDDATAONLY = "FailedDataOnly"
    ALLDATA = "AllData"


class IcebergS3BackupMode:
    """IcebergS3BackupMode enum values."""

    FAILEDDATAONLY = "FailedDataOnly"
    ALLDATA = "AllData"


class KeyType:
    """KeyType enum values."""

    AWS_OWNED_CMK = "AWS_OWNED_CMK"
    CUSTOMER_MANAGED_CMK = "CUSTOMER_MANAGED_CMK"


class NoEncryptionConfig:
    """NoEncryptionConfig enum values."""

    NOENCRYPTION = "NoEncryption"


class OrcCompression:
    """OrcCompression enum values."""

    NONE = "NONE"
    ZLIB = "ZLIB"
    SNAPPY = "SNAPPY"


class OrcFormatVersion:
    """OrcFormatVersion enum values."""

    V0_11 = "V0_11"
    V0_12 = "V0_12"


class ParquetCompression:
    """ParquetCompression enum values."""

    UNCOMPRESSED = "UNCOMPRESSED"
    GZIP = "GZIP"
    SNAPPY = "SNAPPY"


class ParquetWriterVersion:
    """ParquetWriterVersion enum values."""

    V1 = "V1"
    V2 = "V2"


class ProcessorParameterName:
    """ProcessorParameterName enum values."""

    LAMBDAARN = "LambdaArn"
    NUMBEROFRETRIES = "NumberOfRetries"
    METADATAEXTRACTIONQUERY = "MetadataExtractionQuery"
    JSONPARSINGENGINE = "JsonParsingEngine"
    ROLEARN = "RoleArn"
    BUFFERSIZEINMBS = "BufferSizeInMBs"
    BUFFERINTERVALINSECONDS = "BufferIntervalInSeconds"
    SUBRECORDTYPE = "SubRecordType"
    DELIMITER = "Delimiter"
    COMPRESSIONFORMAT = "CompressionFormat"
    DATAMESSAGEEXTRACTION = "DataMessageExtraction"


class ProcessorType:
    """ProcessorType enum values."""

    RECORDDEAGGREGATION = "RecordDeAggregation"
    DECOMPRESSION = "Decompression"
    CLOUDWATCHLOGPROCESSING = "CloudWatchLogProcessing"
    LAMBDA = "Lambda"
    METADATAEXTRACTION = "MetadataExtraction"
    APPENDDELIMITERTORECORD = "AppendDelimiterToRecord"


class RedshiftS3BackupMode:
    """RedshiftS3BackupMode enum values."""

    DISABLED = "Disabled"
    ENABLED = "Enabled"


class S3BackupMode:
    """S3BackupMode enum values."""

    DISABLED = "Disabled"
    ENABLED = "Enabled"


class SSLMode:
    """SSLMode enum values."""

    DISABLED = "Disabled"
    ENABLED = "Enabled"


class SnapshotRequestedBy:
    """SnapshotRequestedBy enum values."""

    USER = "USER"
    FIREHOSE = "FIREHOSE"


class SnapshotStatus:
    """SnapshotStatus enum values."""

    IN_PROGRESS = "IN_PROGRESS"
    COMPLETE = "COMPLETE"
    SUSPENDED = "SUSPENDED"


class SnowflakeDataLoadingOption:
    """SnowflakeDataLoadingOption enum values."""

    JSON_MAPPING = "JSON_MAPPING"
    VARIANT_CONTENT_MAPPING = "VARIANT_CONTENT_MAPPING"
    VARIANT_CONTENT_AND_METADATA_MAPPING = "VARIANT_CONTENT_AND_METADATA_MAPPING"


class SnowflakeS3BackupMode:
    """SnowflakeS3BackupMode enum values."""

    FAILEDDATAONLY = "FailedDataOnly"
    ALLDATA = "AllData"


class SplunkS3BackupMode:
    """SplunkS3BackupMode enum values."""

    FAILEDEVENTSONLY = "FailedEventsOnly"
    ALLEVENTS = "AllEvents"


# Convenient aliases for enum values
FAILEDDOCUMENTSONLY = AmazonOpenSearchServerlessS3BackupMode.FAILEDDOCUMENTSONLY
ALLDOCUMENTS = AmazonOpenSearchServerlessS3BackupMode.ALLDOCUMENTS
NOROTATION = AmazonopensearchserviceIndexRotationPeriod.NOROTATION
ONEHOUR = AmazonopensearchserviceIndexRotationPeriod.ONEHOUR
ONEDAY = AmazonopensearchserviceIndexRotationPeriod.ONEDAY
ONEWEEK = AmazonopensearchserviceIndexRotationPeriod.ONEWEEK
ONEMONTH = AmazonopensearchserviceIndexRotationPeriod.ONEMONTH
FAILEDDOCUMENTSONLY = AmazonopensearchserviceS3BackupMode.FAILEDDOCUMENTSONLY
ALLDOCUMENTS = AmazonopensearchserviceS3BackupMode.ALLDOCUMENTS
UNCOMPRESSED = CompressionFormat.UNCOMPRESSED
GZIP = CompressionFormat.GZIP
ZIP = CompressionFormat.ZIP
SNAPPY = CompressionFormat.SNAPPY
HADOOP_SNAPPY = CompressionFormat.HADOOP_SNAPPY
PUBLIC = Connectivity.PUBLIC
PRIVATE = Connectivity.PRIVATE
NONE = ContentEncoding.NONE
GZIP = ContentEncoding.GZIP
MYSQL = DatabaseType.MYSQL
POSTGRESQL = DatabaseType.POSTGRESQL
FIREHOSE_DEFAULT = DefaultDocumentIdFormat.FIREHOSE_DEFAULT
NO_DOCUMENT_ID = DefaultDocumentIdFormat.NO_DOCUMENT_ID
ENABLED = DeliveryStreamEncryptionStatus.ENABLED
ENABLING = DeliveryStreamEncryptionStatus.ENABLING
ENABLING_FAILED = DeliveryStreamEncryptionStatus.ENABLING_FAILED
DISABLED = DeliveryStreamEncryptionStatus.DISABLED
DISABLING = DeliveryStreamEncryptionStatus.DISABLING
DISABLING_FAILED = DeliveryStreamEncryptionStatus.DISABLING_FAILED
VPC_ENDPOINT_SERVICE_NAME_NOT_FOUND = DeliveryStreamFailureType.VPC_ENDPOINT_SERVICE_NAME_NOT_FOUND
VPC_INTERFACE_ENDPOINT_SERVICE_ACCESS_DENIED = DeliveryStreamFailureType.VPC_INTERFACE_ENDPOINT_SERVICE_ACCESS_DENIED
RETIRE_KMS_GRANT_FAILED = DeliveryStreamFailureType.RETIRE_KMS_GRANT_FAILED
CREATE_KMS_GRANT_FAILED = DeliveryStreamFailureType.CREATE_KMS_GRANT_FAILED
KMS_ACCESS_DENIED = DeliveryStreamFailureType.KMS_ACCESS_DENIED
DISABLED_KMS_KEY = DeliveryStreamFailureType.DISABLED_KMS_KEY
INVALID_KMS_KEY = DeliveryStreamFailureType.INVALID_KMS_KEY
KMS_KEY_NOT_FOUND = DeliveryStreamFailureType.KMS_KEY_NOT_FOUND
KMS_OPT_IN_REQUIRED = DeliveryStreamFailureType.KMS_OPT_IN_REQUIRED
CREATE_ENI_FAILED = DeliveryStreamFailureType.CREATE_ENI_FAILED
DELETE_ENI_FAILED = DeliveryStreamFailureType.DELETE_ENI_FAILED
SUBNET_NOT_FOUND = DeliveryStreamFailureType.SUBNET_NOT_FOUND
SECURITY_GROUP_NOT_FOUND = DeliveryStreamFailureType.SECURITY_GROUP_NOT_FOUND
ENI_ACCESS_DENIED = DeliveryStreamFailureType.ENI_ACCESS_DENIED
SUBNET_ACCESS_DENIED = DeliveryStreamFailureType.SUBNET_ACCESS_DENIED
SECURITY_GROUP_ACCESS_DENIED = DeliveryStreamFailureType.SECURITY_GROUP_ACCESS_DENIED
UNKNOWN_ERROR = DeliveryStreamFailureType.UNKNOWN_ERROR
CREATING = DeliveryStreamStatus.CREATING
CREATING_FAILED = DeliveryStreamStatus.CREATING_FAILED
DELETING = DeliveryStreamStatus.DELETING
DELETING_FAILED = DeliveryStreamStatus.DELETING_FAILED
ACTIVE = DeliveryStreamStatus.ACTIVE
DIRECTPUT = DeliveryStreamType.DIRECTPUT
KINESISSTREAMASSOURCE = DeliveryStreamType.KINESISSTREAMASSOURCE
MSKASSOURCE = DeliveryStreamType.MSKASSOURCE
DATABASEASSOURCE = DeliveryStreamType.DATABASEASSOURCE
NOROTATION = ElasticsearchIndexRotationPeriod.NOROTATION
ONEHOUR = ElasticsearchIndexRotationPeriod.ONEHOUR
ONEDAY = ElasticsearchIndexRotationPeriod.ONEDAY
ONEWEEK = ElasticsearchIndexRotationPeriod.ONEWEEK
ONEMONTH = ElasticsearchIndexRotationPeriod.ONEMONTH
FAILEDDOCUMENTSONLY = ElasticsearchS3BackupMode.FAILEDDOCUMENTSONLY
ALLDOCUMENTS = ElasticsearchS3BackupMode.ALLDOCUMENTS
RAW = HECEndpointType.RAW
EVENT = HECEndpointType.EVENT
FAILEDDATAONLY = HttpEndpointS3BackupMode.FAILEDDATAONLY
ALLDATA = HttpEndpointS3BackupMode.ALLDATA
FAILEDDATAONLY = IcebergS3BackupMode.FAILEDDATAONLY
ALLDATA = IcebergS3BackupMode.ALLDATA
AWS_OWNED_CMK = KeyType.AWS_OWNED_CMK
CUSTOMER_MANAGED_CMK = KeyType.CUSTOMER_MANAGED_CMK
NOENCRYPTION = NoEncryptionConfig.NOENCRYPTION
NONE = OrcCompression.NONE
ZLIB = OrcCompression.ZLIB
SNAPPY = OrcCompression.SNAPPY
V0_11 = OrcFormatVersion.V0_11
V0_12 = OrcFormatVersion.V0_12
UNCOMPRESSED = ParquetCompression.UNCOMPRESSED
GZIP = ParquetCompression.GZIP
SNAPPY = ParquetCompression.SNAPPY
V1 = ParquetWriterVersion.V1
V2 = ParquetWriterVersion.V2
LAMBDAARN = ProcessorParameterName.LAMBDAARN
NUMBEROFRETRIES = ProcessorParameterName.NUMBEROFRETRIES
METADATAEXTRACTIONQUERY = ProcessorParameterName.METADATAEXTRACTIONQUERY
JSONPARSINGENGINE = ProcessorParameterName.JSONPARSINGENGINE
ROLEARN = ProcessorParameterName.ROLEARN
BUFFERSIZEINMBS = ProcessorParameterName.BUFFERSIZEINMBS
BUFFERINTERVALINSECONDS = ProcessorParameterName.BUFFERINTERVALINSECONDS
SUBRECORDTYPE = ProcessorParameterName.SUBRECORDTYPE
DELIMITER = ProcessorParameterName.DELIMITER
COMPRESSIONFORMAT = ProcessorParameterName.COMPRESSIONFORMAT
DATAMESSAGEEXTRACTION = ProcessorParameterName.DATAMESSAGEEXTRACTION
RECORDDEAGGREGATION = ProcessorType.RECORDDEAGGREGATION
DECOMPRESSION = ProcessorType.DECOMPRESSION
CLOUDWATCHLOGPROCESSING = ProcessorType.CLOUDWATCHLOGPROCESSING
LAMBDA = ProcessorType.LAMBDA
METADATAEXTRACTION = ProcessorType.METADATAEXTRACTION
APPENDDELIMITERTORECORD = ProcessorType.APPENDDELIMITERTORECORD
DISABLED = RedshiftS3BackupMode.DISABLED
ENABLED = RedshiftS3BackupMode.ENABLED
DISABLED = S3BackupMode.DISABLED
ENABLED = S3BackupMode.ENABLED
DISABLED = SSLMode.DISABLED
ENABLED = SSLMode.ENABLED
USER = SnapshotRequestedBy.USER
FIREHOSE = SnapshotRequestedBy.FIREHOSE
IN_PROGRESS = SnapshotStatus.IN_PROGRESS
COMPLETE = SnapshotStatus.COMPLETE
SUSPENDED = SnapshotStatus.SUSPENDED
JSON_MAPPING = SnowflakeDataLoadingOption.JSON_MAPPING
VARIANT_CONTENT_MAPPING = SnowflakeDataLoadingOption.VARIANT_CONTENT_MAPPING
VARIANT_CONTENT_AND_METADATA_MAPPING = SnowflakeDataLoadingOption.VARIANT_CONTENT_AND_METADATA_MAPPING
FAILEDDATAONLY = SnowflakeS3BackupMode.FAILEDDATAONLY
ALLDATA = SnowflakeS3BackupMode.ALLDATA
FAILEDEVENTSONLY = SplunkS3BackupMode.FAILEDEVENTSONLY
ALLEVENTS = SplunkS3BackupMode.ALLEVENTS


@dataclass
class AmazonOpenSearchServerlessBufferingHints:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "interval_in_seconds": "IntervalInSeconds",
        "size_in_m_bs": "SizeInMBs",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    interval_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    size_in_m_bs: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class AmazonOpenSearchServerlessDestinationConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "index_name": "IndexName",
        "s3_configuration": "S3Configuration",
        "buffering_hints": "BufferingHints",
        "retry_options": "RetryOptions",
        "collection_endpoint": "CollectionEndpoint",
        "vpc_configuration": "VpcConfiguration",
        "processing_configuration": "ProcessingConfiguration",
        "cloud_watch_logging_options": "CloudWatchLoggingOptions",
        "role_arn": "RoleARN",
        "s3_backup_mode": "S3BackupMode",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    index_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_configuration: Optional[S3DestinationConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    buffering_hints: Optional[AmazonOpenSearchServerlessBufferingHints] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    retry_options: Optional[AmazonOpenSearchServerlessRetryOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    collection_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_configuration: Optional[VpcConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    processing_configuration: Optional[ProcessingConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloud_watch_logging_options: Optional[CloudWatchLoggingOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_backup_mode: Optional[Union[str, AmazonOpenSearchServerlessS3BackupMode, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class AmazonOpenSearchServerlessRetryOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "duration_in_seconds": "DurationInSeconds",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    duration_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class AmazonopensearchserviceBufferingHints:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "interval_in_seconds": "IntervalInSeconds",
        "size_in_m_bs": "SizeInMBs",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    interval_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    size_in_m_bs: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class AmazonopensearchserviceDestinationConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "type_name": "TypeName",
        "index_rotation_period": "IndexRotationPeriod",
        "processing_configuration": "ProcessingConfiguration",
        "cluster_endpoint": "ClusterEndpoint",
        "domain_arn": "DomainARN",
        "role_arn": "RoleARN",
        "s3_backup_mode": "S3BackupMode",
        "index_name": "IndexName",
        "document_id_options": "DocumentIdOptions",
        "s3_configuration": "S3Configuration",
        "buffering_hints": "BufferingHints",
        "retry_options": "RetryOptions",
        "vpc_configuration": "VpcConfiguration",
        "cloud_watch_logging_options": "CloudWatchLoggingOptions",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    index_rotation_period: Optional[Union[str, AmazonopensearchserviceIndexRotationPeriod, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    processing_configuration: Optional[ProcessingConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cluster_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    domain_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_backup_mode: Optional[Union[str, AmazonopensearchserviceS3BackupMode, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    index_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    document_id_options: Optional[DocumentIdOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_configuration: Optional[S3DestinationConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    buffering_hints: Optional[AmazonopensearchserviceBufferingHints] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    retry_options: Optional[AmazonopensearchserviceRetryOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_configuration: Optional[VpcConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloud_watch_logging_options: Optional[CloudWatchLoggingOptions] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class AmazonopensearchserviceRetryOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "duration_in_seconds": "DurationInSeconds",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    duration_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class AuthenticationConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "connectivity": "Connectivity",
        "role_arn": "RoleARN",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    connectivity: Optional[Union[str, Connectivity, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class BufferingHints:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "interval_in_seconds": "IntervalInSeconds",
        "size_in_m_bs": "SizeInMBs",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    interval_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    size_in_m_bs: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class CatalogConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "catalog_arn": "CatalogArn",
        "warehouse_location": "WarehouseLocation",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    catalog_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    warehouse_location: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class CloudWatchLoggingOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "log_stream_name": "LogStreamName",
        "enabled": "Enabled",
        "log_group_name": "LogGroupName",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_stream_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class CopyCommand:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "data_table_name": "DataTableName",
        "copy_options": "CopyOptions",
        "data_table_columns": "DataTableColumns",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_table_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    copy_options: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_table_columns: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class DataFormatConversionConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "input_format_configuration": "InputFormatConfiguration",
        "enabled": "Enabled",
        "schema_configuration": "SchemaConfiguration",
        "output_format_configuration": "OutputFormatConfiguration",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    input_format_configuration: Optional[InputFormatConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    schema_configuration: Optional[SchemaConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    output_format_configuration: Optional[OutputFormatConfiguration] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class DatabaseColumns:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "exclude": "Exclude",
        "include": "Include",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    exclude: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    include: Optional[Union[list[str], Ref]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class DatabaseSourceAuthenticationConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "secrets_manager_configuration": "SecretsManagerConfiguration",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    secrets_manager_configuration: Optional[SecretsManagerConfiguration] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class DatabaseSourceConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "digest": "Digest",
        "port": "Port",
        "public_certificate": "PublicCertificate",
        "columns": "Columns",
        "type_": "Type",
        "surrogate_keys": "SurrogateKeys",
        "databases": "Databases",
        "endpoint": "Endpoint",
        "ssl_mode": "SSLMode",
        "snapshot_watermark_table": "SnapshotWatermarkTable",
        "database_source_authentication_configuration": "DatabaseSourceAuthenticationConfiguration",
        "tables": "Tables",
        "database_source_vpc_configuration": "DatabaseSourceVPCConfiguration",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    digest: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    public_certificate: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    columns: Optional[DatabaseColumns] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, DatabaseType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    surrogate_keys: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    databases: Optional[Databases] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ssl_mode: Optional[Union[str, SSLMode, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    snapshot_watermark_table: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    database_source_authentication_configuration: Optional[DatabaseSourceAuthenticationConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tables: Optional[DatabaseTables] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    database_source_vpc_configuration: Optional[DatabaseSourceVPCConfiguration] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class DatabaseSourceVPCConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "vpc_endpoint_service_name": "VpcEndpointServiceName",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_endpoint_service_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class DatabaseTables:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "exclude": "Exclude",
        "include": "Include",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    exclude: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    include: Optional[Union[list[str], Ref]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class Databases:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "exclude": "Exclude",
        "include": "Include",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    exclude: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    include: Optional[Union[list[str], Ref]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class DeliveryStreamEncryptionConfigurationInput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "key_type": "KeyType",
        "key_arn": "KeyARN",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key_type: Optional[Union[str, KeyType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class Deserializer:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "hive_json_ser_de": "HiveJsonSerDe",
        "open_x_json_ser_de": "OpenXJsonSerDe",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hive_json_ser_de: Optional[HiveJsonSerDe] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    open_x_json_ser_de: Optional[OpenXJsonSerDe] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class DestinationTableConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "destination_database_name": "DestinationDatabaseName",
        "s3_error_output_prefix": "S3ErrorOutputPrefix",
        "destination_table_name": "DestinationTableName",
        "unique_keys": "UniqueKeys",
        "partition_spec": "PartitionSpec",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_database_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_error_output_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_table_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    unique_keys: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    partition_spec: Optional[PartitionSpec] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class DirectPutSourceConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "throughput_hint_in_m_bs": "ThroughputHintInMBs",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    throughput_hint_in_m_bs: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class DocumentIdOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "default_document_id_format": "DefaultDocumentIdFormat",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_document_id_format: Optional[Union[str, DefaultDocumentIdFormat, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class DynamicPartitioningConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "enabled": "Enabled",
        "retry_options": "RetryOptions",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    retry_options: Optional[RetryOptions] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class ElasticsearchBufferingHints:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "interval_in_seconds": "IntervalInSeconds",
        "size_in_m_bs": "SizeInMBs",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    interval_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    size_in_m_bs: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class ElasticsearchDestinationConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "type_name": "TypeName",
        "index_rotation_period": "IndexRotationPeriod",
        "processing_configuration": "ProcessingConfiguration",
        "cluster_endpoint": "ClusterEndpoint",
        "domain_arn": "DomainARN",
        "role_arn": "RoleARN",
        "s3_backup_mode": "S3BackupMode",
        "index_name": "IndexName",
        "document_id_options": "DocumentIdOptions",
        "s3_configuration": "S3Configuration",
        "buffering_hints": "BufferingHints",
        "retry_options": "RetryOptions",
        "vpc_configuration": "VpcConfiguration",
        "cloud_watch_logging_options": "CloudWatchLoggingOptions",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    index_rotation_period: Optional[Union[str, ElasticsearchIndexRotationPeriod, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    processing_configuration: Optional[ProcessingConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cluster_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    domain_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_backup_mode: Optional[Union[str, ElasticsearchS3BackupMode, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    index_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    document_id_options: Optional[DocumentIdOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_configuration: Optional[S3DestinationConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    buffering_hints: Optional[ElasticsearchBufferingHints] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    retry_options: Optional[ElasticsearchRetryOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_configuration: Optional[VpcConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloud_watch_logging_options: Optional[CloudWatchLoggingOptions] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class ElasticsearchRetryOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "duration_in_seconds": "DurationInSeconds",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    duration_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class EncryptionConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "kms_encryption_config": "KMSEncryptionConfig",
        "no_encryption_config": "NoEncryptionConfig",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_encryption_config: Optional[KMSEncryptionConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    no_encryption_config: Optional[Union[str, NoEncryptionConfig, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class ExtendedS3DestinationConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "error_output_prefix": "ErrorOutputPrefix",
        "s3_backup_configuration": "S3BackupConfiguration",
        "bucket_arn": "BucketARN",
        "compression_format": "CompressionFormat",
        "data_format_conversion_configuration": "DataFormatConversionConfiguration",
        "encryption_configuration": "EncryptionConfiguration",
        "custom_time_zone": "CustomTimeZone",
        "dynamic_partitioning_configuration": "DynamicPartitioningConfiguration",
        "prefix": "Prefix",
        "processing_configuration": "ProcessingConfiguration",
        "role_arn": "RoleARN",
        "s3_backup_mode": "S3BackupMode",
        "buffering_hints": "BufferingHints",
        "file_extension": "FileExtension",
        "cloud_watch_logging_options": "CloudWatchLoggingOptions",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    error_output_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_backup_configuration: Optional[S3DestinationConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bucket_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    compression_format: Optional[Union[str, CompressionFormat, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_format_conversion_configuration: Optional[DataFormatConversionConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    encryption_configuration: Optional[EncryptionConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_time_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dynamic_partitioning_configuration: Optional[DynamicPartitioningConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    processing_configuration: Optional[ProcessingConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_backup_mode: Optional[Union[str, S3BackupMode, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    buffering_hints: Optional[BufferingHints] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    file_extension: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloud_watch_logging_options: Optional[CloudWatchLoggingOptions] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class HiveJsonSerDe:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "timestamp_formats": "TimestampFormats",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    timestamp_formats: Optional[Union[list[str], Ref]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class HttpEndpointCommonAttribute:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "attribute_value": "AttributeValue",
        "attribute_name": "AttributeName",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    attribute_value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    attribute_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class HttpEndpointConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "access_key": "AccessKey",
        "url": "Url",
        "name": "Name",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    access_key: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    url: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class HttpEndpointDestinationConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "request_configuration": "RequestConfiguration",
        "s3_configuration": "S3Configuration",
        "buffering_hints": "BufferingHints",
        "retry_options": "RetryOptions",
        "secrets_manager_configuration": "SecretsManagerConfiguration",
        "endpoint_configuration": "EndpointConfiguration",
        "processing_configuration": "ProcessingConfiguration",
        "role_arn": "RoleARN",
        "cloud_watch_logging_options": "CloudWatchLoggingOptions",
        "s3_backup_mode": "S3BackupMode",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    request_configuration: Optional[HttpEndpointRequestConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_configuration: Optional[S3DestinationConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    buffering_hints: Optional[BufferingHints] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    retry_options: Optional[RetryOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    secrets_manager_configuration: Optional[SecretsManagerConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    endpoint_configuration: Optional[HttpEndpointConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    processing_configuration: Optional[ProcessingConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloud_watch_logging_options: Optional[CloudWatchLoggingOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_backup_mode: Optional[Union[str, HttpEndpointS3BackupMode, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class HttpEndpointRequestConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "common_attributes": "CommonAttributes",
        "content_encoding": "ContentEncoding",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    common_attributes: Optional[list[HttpEndpointCommonAttribute]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    content_encoding: Optional[Union[str, ContentEncoding, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class IcebergDestinationConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "catalog_configuration": "CatalogConfiguration",
        "s3_configuration": "S3Configuration",
        "destination_table_configuration_list": "DestinationTableConfigurationList",
        "buffering_hints": "BufferingHints",
        "table_creation_configuration": "TableCreationConfiguration",
        "retry_options": "RetryOptions",
        "s3_backup_mode": "s3BackupMode",
        "processing_configuration": "ProcessingConfiguration",
        "schema_evolution_configuration": "SchemaEvolutionConfiguration",
        "append_only": "AppendOnly",
        "cloud_watch_logging_options": "CloudWatchLoggingOptions",
        "role_arn": "RoleARN",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    catalog_configuration: Optional[CatalogConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_configuration: Optional[S3DestinationConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_table_configuration_list: Optional[list[DestinationTableConfiguration]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    buffering_hints: Optional[BufferingHints] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    table_creation_configuration: Optional[TableCreationConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    retry_options: Optional[RetryOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_backup_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    processing_configuration: Optional[ProcessingConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    schema_evolution_configuration: Optional[SchemaEvolutionConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    append_only: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloud_watch_logging_options: Optional[CloudWatchLoggingOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class InputFormatConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "deserializer": "Deserializer",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    deserializer: Optional[Deserializer] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class KMSEncryptionConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "awskms_key_arn": "AWSKMSKeyARN",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    awskms_key_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class KinesisStreamSourceConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "kinesis_stream_arn": "KinesisStreamARN",
        "role_arn": "RoleARN",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kinesis_stream_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class MSKSourceConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "authentication_configuration": "AuthenticationConfiguration",
        "read_from_timestamp": "ReadFromTimestamp",
        "msk_cluster_arn": "MSKClusterARN",
        "topic_name": "TopicName",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    authentication_configuration: Optional[AuthenticationConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    read_from_timestamp: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    msk_cluster_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    topic_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class OpenXJsonSerDe:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "convert_dots_in_json_keys_to_underscores": "ConvertDotsInJsonKeysToUnderscores",
        "column_to_json_key_mappings": "ColumnToJsonKeyMappings",
        "case_insensitive": "CaseInsensitive",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    convert_dots_in_json_keys_to_underscores: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    column_to_json_key_mappings: Optional[dict[str, str]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    case_insensitive: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class OrcSerDe:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "padding_tolerance": "PaddingTolerance",
        "compression": "Compression",
        "stripe_size_bytes": "StripeSizeBytes",
        "bloom_filter_columns": "BloomFilterColumns",
        "bloom_filter_false_positive_probability": "BloomFilterFalsePositiveProbability",
        "enable_padding": "EnablePadding",
        "format_version": "FormatVersion",
        "row_index_stride": "RowIndexStride",
        "block_size_bytes": "BlockSizeBytes",
        "dictionary_key_threshold": "DictionaryKeyThreshold",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    padding_tolerance: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    compression: Optional[Union[str, OrcCompression, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    stripe_size_bytes: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bloom_filter_columns: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bloom_filter_false_positive_probability: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_padding: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    format_version: Optional[Union[str, OrcFormatVersion, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    row_index_stride: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    block_size_bytes: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dictionary_key_threshold: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class OutputFormatConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "serializer": "Serializer",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    serializer: Optional[Serializer] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class ParquetSerDe:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "compression": "Compression",
        "block_size_bytes": "BlockSizeBytes",
        "enable_dictionary_compression": "EnableDictionaryCompression",
        "page_size_bytes": "PageSizeBytes",
        "max_padding_bytes": "MaxPaddingBytes",
        "writer_version": "WriterVersion",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    compression: Optional[Union[str, ParquetCompression, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    block_size_bytes: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_dictionary_compression: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    page_size_bytes: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_padding_bytes: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    writer_version: Optional[Union[str, ParquetWriterVersion, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class PartitionField:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "source_name": "SourceName",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class PartitionSpec:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "identity": "Identity",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    identity: Optional[list[PartitionField]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class ProcessingConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "enabled": "Enabled",
        "processors": "Processors",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    processors: Optional[list[Processor]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class Processor:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "type_": "Type",
        "parameters": "Parameters",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, ProcessorType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parameters: Optional[list[ProcessorParameter]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class ProcessorParameter:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "parameter_value": "ParameterValue",
        "parameter_name": "ParameterName",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parameter_value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parameter_name: Optional[Union[str, ProcessorParameterName, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class RedshiftDestinationConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "s3_backup_configuration": "S3BackupConfiguration",
        "s3_configuration": "S3Configuration",
        "username": "Username",
        "copy_command": "CopyCommand",
        "retry_options": "RetryOptions",
        "secrets_manager_configuration": "SecretsManagerConfiguration",
        "processing_configuration": "ProcessingConfiguration",
        "cloud_watch_logging_options": "CloudWatchLoggingOptions",
        "cluster_jdbcurl": "ClusterJDBCURL",
        "role_arn": "RoleARN",
        "password": "Password",
        "s3_backup_mode": "S3BackupMode",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_backup_configuration: Optional[S3DestinationConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_configuration: Optional[S3DestinationConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    username: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    copy_command: Optional[CopyCommand] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    retry_options: Optional[RedshiftRetryOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    secrets_manager_configuration: Optional[SecretsManagerConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    processing_configuration: Optional[ProcessingConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloud_watch_logging_options: Optional[CloudWatchLoggingOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cluster_jdbcurl: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    password: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_backup_mode: Optional[Union[str, RedshiftS3BackupMode, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class RedshiftRetryOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "duration_in_seconds": "DurationInSeconds",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    duration_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class RetryOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "duration_in_seconds": "DurationInSeconds",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    duration_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class S3DestinationConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "error_output_prefix": "ErrorOutputPrefix",
        "bucket_arn": "BucketARN",
        "buffering_hints": "BufferingHints",
        "compression_format": "CompressionFormat",
        "encryption_configuration": "EncryptionConfiguration",
        "prefix": "Prefix",
        "cloud_watch_logging_options": "CloudWatchLoggingOptions",
        "role_arn": "RoleARN",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    error_output_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bucket_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    buffering_hints: Optional[BufferingHints] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    compression_format: Optional[Union[str, CompressionFormat, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    encryption_configuration: Optional[EncryptionConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloud_watch_logging_options: Optional[CloudWatchLoggingOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class SchemaConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "version_id": "VersionId",
        "table_name": "TableName",
        "database_name": "DatabaseName",
        "region": "Region",
        "catalog_id": "CatalogId",
        "role_arn": "RoleARN",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    version_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    table_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    database_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    region: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    catalog_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class SchemaEvolutionConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "enabled": "Enabled",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class SecretsManagerConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "secret_arn": "SecretARN",
        "enabled": "Enabled",
        "role_arn": "RoleARN",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    secret_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class Serializer:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "orc_ser_de": "OrcSerDe",
        "parquet_ser_de": "ParquetSerDe",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    orc_ser_de: Optional[OrcSerDe] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parquet_ser_de: Optional[ParquetSerDe] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class SnowflakeBufferingHints:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "interval_in_seconds": "IntervalInSeconds",
        "size_in_m_bs": "SizeInMBs",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    interval_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    size_in_m_bs: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class SnowflakeDestinationConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "private_key": "PrivateKey",
        "user": "User",
        "table": "Table",
        "snowflake_vpc_configuration": "SnowflakeVpcConfiguration",
        "data_loading_option": "DataLoadingOption",
        "schema": "Schema",
        "content_column_name": "ContentColumnName",
        "secrets_manager_configuration": "SecretsManagerConfiguration",
        "snowflake_role_configuration": "SnowflakeRoleConfiguration",
        "processing_configuration": "ProcessingConfiguration",
        "account_url": "AccountUrl",
        "role_arn": "RoleARN",
        "s3_backup_mode": "S3BackupMode",
        "s3_configuration": "S3Configuration",
        "buffering_hints": "BufferingHints",
        "meta_data_column_name": "MetaDataColumnName",
        "database": "Database",
        "retry_options": "RetryOptions",
        "key_passphrase": "KeyPassphrase",
        "cloud_watch_logging_options": "CloudWatchLoggingOptions",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_key: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    user: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    table: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    snowflake_vpc_configuration: Optional[SnowflakeVpcConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_loading_option: Optional[Union[str, SnowflakeDataLoadingOption, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    schema: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    content_column_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    secrets_manager_configuration: Optional[SecretsManagerConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    snowflake_role_configuration: Optional[SnowflakeRoleConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    processing_configuration: Optional[ProcessingConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    account_url: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_backup_mode: Optional[Union[str, SnowflakeS3BackupMode, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_configuration: Optional[S3DestinationConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    buffering_hints: Optional[SnowflakeBufferingHints] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    meta_data_column_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    database: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    retry_options: Optional[SnowflakeRetryOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key_passphrase: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloud_watch_logging_options: Optional[CloudWatchLoggingOptions] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class SnowflakeRetryOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "duration_in_seconds": "DurationInSeconds",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    duration_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class SnowflakeRoleConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "snowflake_role": "SnowflakeRole",
        "enabled": "Enabled",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    snowflake_role: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class SnowflakeVpcConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "private_link_vpce_id": "PrivateLinkVpceId",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_link_vpce_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class SplunkBufferingHints:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "interval_in_seconds": "IntervalInSeconds",
        "size_in_m_bs": "SizeInMBs",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    interval_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    size_in_m_bs: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class SplunkDestinationConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "hec_endpoint": "HECEndpoint",
        "s3_configuration": "S3Configuration",
        "buffering_hints": "BufferingHints",
        "hec_token": "HECToken",
        "retry_options": "RetryOptions",
        "hec_endpoint_type": "HECEndpointType",
        "secrets_manager_configuration": "SecretsManagerConfiguration",
        "hec_acknowledgment_timeout_in_seconds": "HECAcknowledgmentTimeoutInSeconds",
        "processing_configuration": "ProcessingConfiguration",
        "cloud_watch_logging_options": "CloudWatchLoggingOptions",
        "s3_backup_mode": "S3BackupMode",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hec_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_configuration: Optional[S3DestinationConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    buffering_hints: Optional[SplunkBufferingHints] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hec_token: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    retry_options: Optional[SplunkRetryOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hec_endpoint_type: Optional[Union[str, HECEndpointType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    secrets_manager_configuration: Optional[SecretsManagerConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hec_acknowledgment_timeout_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    processing_configuration: Optional[ProcessingConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloud_watch_logging_options: Optional[CloudWatchLoggingOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_backup_mode: Optional[Union[str, SplunkS3BackupMode, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class SplunkRetryOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "duration_in_seconds": "DurationInSeconds",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    duration_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TableCreationConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "enabled": "Enabled",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class VpcConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kin"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "subnet_ids": "SubnetIds",
        "security_group_ids": "SecurityGroupIds",
        "role_arn": "RoleARN",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class DeliveryStream(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kines"""

    resource_type: ClassVar[str] = "AWS::KinesisFirehose::DeliveryStream"
    _property_mappings: ClassVar[dict[str, str]] = {
        "delivery_stream_encryption_configuration_input": "DeliveryStreamEncryptionConfigurationInput",
        "http_endpoint_destination_configuration": "HttpEndpointDestinationConfiguration",
        "kinesis_stream_source_configuration": "KinesisStreamSourceConfiguration",
        "delivery_stream_type": "DeliveryStreamType",
        "iceberg_destination_configuration": "IcebergDestinationConfiguration",
        "redshift_destination_configuration": "RedshiftDestinationConfiguration",
        "amazonopensearchservice_destination_configuration": "AmazonopensearchserviceDestinationConfiguration",
        "msk_source_configuration": "MSKSourceConfiguration",
        "direct_put_source_configuration": "DirectPutSourceConfiguration",
        "splunk_destination_configuration": "SplunkDestinationConfiguration",
        "extended_s3_destination_configuration": "ExtendedS3DestinationConfiguration",
        "amazon_open_search_serverless_destination_configuration": "AmazonOpenSearchServerlessDestinationConfiguration",
        "elasticsearch_destination_configuration": "ElasticsearchDestinationConfiguration",
        "snowflake_destination_configuration": "SnowflakeDestinationConfiguration",
        "database_source_configuration": "DatabaseSourceConfiguration",
        "s3_destination_configuration": "S3DestinationConfiguration",
        "delivery_stream_name": "DeliveryStreamName",
        "tags": "Tags",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    delivery_stream_encryption_configuration_input: Optional[DeliveryStreamEncryptionConfigurationInput] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    http_endpoint_destination_configuration: Optional[HttpEndpointDestinationConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kinesis_stream_source_configuration: Optional[KinesisStreamSourceConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    delivery_stream_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    iceberg_destination_configuration: Optional[IcebergDestinationConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    redshift_destination_configuration: Optional[RedshiftDestinationConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    amazonopensearchservice_destination_configuration: Optional[AmazonopensearchserviceDestinationConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    msk_source_configuration: Optional[MSKSourceConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    direct_put_source_configuration: Optional[DirectPutSourceConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    splunk_destination_configuration: Optional[SplunkDestinationConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    extended_s3_destination_configuration: Optional[ExtendedS3DestinationConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    amazon_open_search_serverless_destination_configuration: Optional[AmazonOpenSearchServerlessDestinationConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    elasticsearch_destination_configuration: Optional[ElasticsearchDestinationConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    snowflake_destination_configuration: Optional[SnowflakeDestinationConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    database_source_configuration: Optional[DatabaseSourceConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    s3_destination_configuration: Optional[S3DestinationConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    delivery_stream_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




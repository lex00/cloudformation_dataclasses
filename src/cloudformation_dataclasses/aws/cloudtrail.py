"""
AWS CloudFormation CloudTrail Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 21:37:35

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service CloudTrail
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class BillingMode:
    """BillingMode enum values."""

    EXTENDABLE_RETENTION_PRICING = "EXTENDABLE_RETENTION_PRICING"
    FIXED_RETENTION_PRICING = "FIXED_RETENTION_PRICING"


class DashboardStatus:
    """DashboardStatus enum values."""

    CREATING = "CREATING"
    CREATED = "CREATED"
    UPDATING = "UPDATING"
    UPDATED = "UPDATED"
    DELETING = "DELETING"


class DashboardType:
    """DashboardType enum values."""

    MANAGED = "MANAGED"
    CUSTOM = "CUSTOM"


class DeliveryStatus:
    """DeliveryStatus enum values."""

    SUCCESS = "SUCCESS"
    FAILED = "FAILED"
    FAILED_SIGNING_FILE = "FAILED_SIGNING_FILE"
    PENDING = "PENDING"
    RESOURCE_NOT_FOUND = "RESOURCE_NOT_FOUND"
    ACCESS_DENIED = "ACCESS_DENIED"
    ACCESS_DENIED_SIGNING_FILE = "ACCESS_DENIED_SIGNING_FILE"
    CANCELLED = "CANCELLED"
    UNKNOWN = "UNKNOWN"


class DestinationType:
    """DestinationType enum values."""

    EVENT_DATA_STORE = "EVENT_DATA_STORE"
    AWS_SERVICE = "AWS_SERVICE"


class EventCategory:
    """EventCategory enum values."""

    INSIGHT = "insight"


class EventCategoryAggregation:
    """EventCategoryAggregation enum values."""

    DATA = "Data"


class EventDataStoreStatus:
    """EventDataStoreStatus enum values."""

    CREATED = "CREATED"
    ENABLED = "ENABLED"
    PENDING_DELETION = "PENDING_DELETION"
    STARTING_INGESTION = "STARTING_INGESTION"
    STOPPING_INGESTION = "STOPPING_INGESTION"
    STOPPED_INGESTION = "STOPPED_INGESTION"


class FederationStatus:
    """FederationStatus enum values."""

    ENABLING = "ENABLING"
    ENABLED = "ENABLED"
    DISABLING = "DISABLING"
    DISABLED = "DISABLED"


class ImportFailureStatus:
    """ImportFailureStatus enum values."""

    FAILED = "FAILED"
    RETRY = "RETRY"
    SUCCEEDED = "SUCCEEDED"


class ImportStatus:
    """ImportStatus enum values."""

    INITIALIZING = "INITIALIZING"
    IN_PROGRESS = "IN_PROGRESS"
    FAILED = "FAILED"
    STOPPED = "STOPPED"
    COMPLETED = "COMPLETED"


class InsightType:
    """InsightType enum values."""

    APICALLRATEINSIGHT = "ApiCallRateInsight"
    APIERRORRATEINSIGHT = "ApiErrorRateInsight"


class InsightsMetricDataType:
    """InsightsMetricDataType enum values."""

    FILLWITHZEROS = "FillWithZeros"
    NONZERODATA = "NonZeroData"


class ListInsightsDataDimensionKey:
    """ListInsightsDataDimensionKey enum values."""

    EVENTID = "EventId"
    EVENTNAME = "EventName"
    EVENTSOURCE = "EventSource"


class ListInsightsDataType:
    """ListInsightsDataType enum values."""

    INSIGHTSEVENTS = "InsightsEvents"


class LookupAttributeKey:
    """LookupAttributeKey enum values."""

    EVENTID = "EventId"
    EVENTNAME = "EventName"
    READONLY = "ReadOnly"
    USERNAME = "Username"
    RESOURCETYPE = "ResourceType"
    RESOURCENAME = "ResourceName"
    EVENTSOURCE = "EventSource"
    ACCESSKEYID = "AccessKeyId"


class MaxEventSize:
    """MaxEventSize enum values."""

    STANDARD = "Standard"
    LARGE = "Large"


class QueryStatus:
    """QueryStatus enum values."""

    QUEUED = "QUEUED"
    RUNNING = "RUNNING"
    FINISHED = "FINISHED"
    FAILED = "FAILED"
    CANCELLED = "CANCELLED"
    TIMED_OUT = "TIMED_OUT"


class ReadWriteType:
    """ReadWriteType enum values."""

    READONLY = "ReadOnly"
    WRITEONLY = "WriteOnly"
    ALL = "All"


class RefreshScheduleFrequencyUnit:
    """RefreshScheduleFrequencyUnit enum values."""

    HOURS = "HOURS"
    DAYS = "DAYS"


class RefreshScheduleStatus:
    """RefreshScheduleStatus enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"


class SourceEventCategory:
    """SourceEventCategory enum values."""

    MANAGEMENT = "Management"
    DATA = "Data"


class Template:
    """Template enum values."""

    API_ACTIVITY = "API_ACTIVITY"
    RESOURCE_ACCESS = "RESOURCE_ACCESS"
    USER_ACTIONS = "USER_ACTIONS"


class Type:
    """Type enum values."""

    TAGCONTEXT = "TagContext"
    REQUESTCONTEXT = "RequestContext"


# Convenient aliases for enum values
EXTENDABLE_RETENTION_PRICING = BillingMode.EXTENDABLE_RETENTION_PRICING
FIXED_RETENTION_PRICING = BillingMode.FIXED_RETENTION_PRICING
CREATING = DashboardStatus.CREATING
CREATED = DashboardStatus.CREATED
UPDATING = DashboardStatus.UPDATING
UPDATED = DashboardStatus.UPDATED
DELETING = DashboardStatus.DELETING
MANAGED = DashboardType.MANAGED
CUSTOM = DashboardType.CUSTOM
SUCCESS = DeliveryStatus.SUCCESS
FAILED = DeliveryStatus.FAILED
FAILED_SIGNING_FILE = DeliveryStatus.FAILED_SIGNING_FILE
PENDING = DeliveryStatus.PENDING
RESOURCE_NOT_FOUND = DeliveryStatus.RESOURCE_NOT_FOUND
ACCESS_DENIED = DeliveryStatus.ACCESS_DENIED
ACCESS_DENIED_SIGNING_FILE = DeliveryStatus.ACCESS_DENIED_SIGNING_FILE
CANCELLED = DeliveryStatus.CANCELLED
UNKNOWN = DeliveryStatus.UNKNOWN
EVENT_DATA_STORE = DestinationType.EVENT_DATA_STORE
AWS_SERVICE = DestinationType.AWS_SERVICE
INSIGHT = EventCategory.INSIGHT
DATA = EventCategoryAggregation.DATA
CREATED = EventDataStoreStatus.CREATED
ENABLED = EventDataStoreStatus.ENABLED
PENDING_DELETION = EventDataStoreStatus.PENDING_DELETION
STARTING_INGESTION = EventDataStoreStatus.STARTING_INGESTION
STOPPING_INGESTION = EventDataStoreStatus.STOPPING_INGESTION
STOPPED_INGESTION = EventDataStoreStatus.STOPPED_INGESTION
ENABLING = FederationStatus.ENABLING
ENABLED = FederationStatus.ENABLED
DISABLING = FederationStatus.DISABLING
DISABLED = FederationStatus.DISABLED
FAILED = ImportFailureStatus.FAILED
RETRY = ImportFailureStatus.RETRY
SUCCEEDED = ImportFailureStatus.SUCCEEDED
INITIALIZING = ImportStatus.INITIALIZING
IN_PROGRESS = ImportStatus.IN_PROGRESS
FAILED = ImportStatus.FAILED
STOPPED = ImportStatus.STOPPED
COMPLETED = ImportStatus.COMPLETED
APICALLRATEINSIGHT = InsightType.APICALLRATEINSIGHT
APIERRORRATEINSIGHT = InsightType.APIERRORRATEINSIGHT
FILLWITHZEROS = InsightsMetricDataType.FILLWITHZEROS
NONZERODATA = InsightsMetricDataType.NONZERODATA
EVENTID = ListInsightsDataDimensionKey.EVENTID
EVENTNAME = ListInsightsDataDimensionKey.EVENTNAME
EVENTSOURCE = ListInsightsDataDimensionKey.EVENTSOURCE
INSIGHTSEVENTS = ListInsightsDataType.INSIGHTSEVENTS
EVENTID = LookupAttributeKey.EVENTID
EVENTNAME = LookupAttributeKey.EVENTNAME
READONLY = LookupAttributeKey.READONLY
USERNAME = LookupAttributeKey.USERNAME
RESOURCETYPE = LookupAttributeKey.RESOURCETYPE
RESOURCENAME = LookupAttributeKey.RESOURCENAME
EVENTSOURCE = LookupAttributeKey.EVENTSOURCE
ACCESSKEYID = LookupAttributeKey.ACCESSKEYID
STANDARD = MaxEventSize.STANDARD
LARGE = MaxEventSize.LARGE
QUEUED = QueryStatus.QUEUED
RUNNING = QueryStatus.RUNNING
FINISHED = QueryStatus.FINISHED
FAILED = QueryStatus.FAILED
CANCELLED = QueryStatus.CANCELLED
TIMED_OUT = QueryStatus.TIMED_OUT
READONLY = ReadWriteType.READONLY
WRITEONLY = ReadWriteType.WRITEONLY
ALL = ReadWriteType.ALL
HOURS = RefreshScheduleFrequencyUnit.HOURS
DAYS = RefreshScheduleFrequencyUnit.DAYS
ENABLED = RefreshScheduleStatus.ENABLED
DISABLED = RefreshScheduleStatus.DISABLED
MANAGEMENT = SourceEventCategory.MANAGEMENT
DATA = SourceEventCategory.DATA
API_ACTIVITY = Template.API_ACTIVITY
RESOURCE_ACCESS = Template.RESOURCE_ACCESS
USER_ACTIONS = Template.USER_ACTIONS
TAGCONTEXT = Type.TAGCONTEXT
REQUESTCONTEXT = Type.REQUESTCONTEXT


@dataclass
class Destination:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "type_": "Type",
        "location": "Location",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, DestinationType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    location: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class Channel(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cloud"""

    resource_type: ClassVar[str] = "AWS::CloudTrail::Channel"
    _property_mappings: ClassVar[dict[str, str]] = {
        "destinations": "Destinations",
        "source": "Source",
        "tags": "Tags",
        "name": "Name",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destinations: Optional[list[Destination]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    @property
    def attr_channel_arn(self) -> GetAtt:
        """Get the ChannelArn attribute."""
        return self.get_att("ChannelArn")




@dataclass
class Frequency:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "value": "Value",
        "unit": "Unit",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    unit: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class RefreshSchedule:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "status": "Status",
        "time_of_day": "TimeOfDay",
        "frequency": "Frequency",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    status: Optional[Union[str, RefreshScheduleStatus, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    time_of_day: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    frequency: Optional[Frequency] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class Widget:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "query_statement": "QueryStatement",
        "query_parameters": "QueryParameters",
        "view_properties": "ViewProperties",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    query_statement: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    query_parameters: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    view_properties: Optional[dict[str, str]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class Dashboard(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cloud"""

    resource_type: ClassVar[str] = "AWS::CloudTrail::Dashboard"
    _property_mappings: ClassVar[dict[str, str]] = {
        "widgets": "Widgets",
        "termination_protection_enabled": "TerminationProtectionEnabled",
        "refresh_schedule": "RefreshSchedule",
        "tags": "Tags",
        "name": "Name",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    widgets: Optional[list[Widget]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    termination_protection_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    refresh_schedule: Optional[RefreshSchedule] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_updated_timestamp(self) -> GetAtt:
        """Get the UpdatedTimestamp attribute."""
        return self.get_att("UpdatedTimestamp")

    @property
    def attr_type(self) -> GetAtt:
        """Get the Type attribute."""
        return self.get_att("Type")

    @property
    def attr_created_timestamp(self) -> GetAtt:
        """Get the CreatedTimestamp attribute."""
        return self.get_att("CreatedTimestamp")

    @property
    def attr_dashboard_arn(self) -> GetAtt:
        """Get the DashboardArn attribute."""
        return self.get_att("DashboardArn")




@dataclass
class AdvancedEventSelector:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "field_selectors": "FieldSelectors",
        "name": "Name",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    field_selectors: Optional[list[AdvancedFieldSelector]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class AdvancedFieldSelector:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "field": "Field",
        "equals": "Equals",
        "not_starts_with": "NotStartsWith",
        "not_ends_with": "NotEndsWith",
        "starts_with": "StartsWith",
        "ends_with": "EndsWith",
        "not_equals": "NotEquals",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    field: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    equals: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    not_starts_with: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    not_ends_with: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    starts_with: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ends_with: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    not_equals: Optional[Union[list[str], Ref]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class ContextKeySelector:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "type_": "Type",
        "equals": "Equals",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Type, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    equals: Optional[Union[list[str], Ref]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class InsightSelector:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "insight_type": "InsightType",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    insight_type: Optional[Union[str, InsightType, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class EventDataStore(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cloud"""

    resource_type: ClassVar[str] = "AWS::CloudTrail::EventDataStore"
    _property_mappings: ClassVar[dict[str, str]] = {
        "max_event_size": "MaxEventSize",
        "kms_key_id": "KmsKeyId",
        "advanced_event_selectors": "AdvancedEventSelectors",
        "termination_protection_enabled": "TerminationProtectionEnabled",
        "multi_region_enabled": "MultiRegionEnabled",
        "retention_period": "RetentionPeriod",
        "federation_enabled": "FederationEnabled",
        "ingestion_enabled": "IngestionEnabled",
        "name": "Name",
        "insight_selectors": "InsightSelectors",
        "organization_enabled": "OrganizationEnabled",
        "federation_role_arn": "FederationRoleArn",
        "insights_destination": "InsightsDestination",
        "billing_mode": "BillingMode",
        "context_key_selectors": "ContextKeySelectors",
        "tags": "Tags",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_event_size: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    advanced_event_selectors: Optional[list[AdvancedEventSelector]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    termination_protection_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    multi_region_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    retention_period: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    federation_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ingestion_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    insight_selectors: Optional[list[InsightSelector]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    organization_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    federation_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    insights_destination: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    billing_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    context_key_selectors: Optional[list[ContextKeySelector]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_updated_timestamp(self) -> GetAtt:
        """Get the UpdatedTimestamp attribute."""
        return self.get_att("UpdatedTimestamp")

    @property
    def attr_event_data_store_arn(self) -> GetAtt:
        """Get the EventDataStoreArn attribute."""
        return self.get_att("EventDataStoreArn")

    @property
    def attr_created_timestamp(self) -> GetAtt:
        """Get the CreatedTimestamp attribute."""
        return self.get_att("CreatedTimestamp")




@dataclass
class ResourcePolicy(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cloud"""

    resource_type: ClassVar[str] = "AWS::CloudTrail::ResourcePolicy"
    _property_mappings: ClassVar[dict[str, str]] = {
        "resource_arn": "ResourceArn",
        "resource_policy": "ResourcePolicy",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resource_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resource_policy: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None



@dataclass
class AdvancedEventSelector:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "field_selectors": "FieldSelectors",
        "name": "Name",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    field_selectors: Optional[list[AdvancedFieldSelector]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class AdvancedFieldSelector:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "field": "Field",
        "equals": "Equals",
        "not_starts_with": "NotStartsWith",
        "not_ends_with": "NotEndsWith",
        "starts_with": "StartsWith",
        "ends_with": "EndsWith",
        "not_equals": "NotEquals",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    field: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    equals: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    not_starts_with: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    not_ends_with: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    starts_with: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ends_with: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    not_equals: Optional[Union[list[str], Ref]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class AggregationConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "event_category": "EventCategory",
        "templates": "Templates",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    event_category: Optional[Union[str, EventCategoryAggregation, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    templates: Optional[Union[list[str], Ref]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class DataResource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "type_": "Type",
        "values": "Values",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    values: Optional[Union[list[str], Ref]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class EventSelector:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "include_management_events": "IncludeManagementEvents",
        "read_write_type": "ReadWriteType",
        "exclude_management_event_sources": "ExcludeManagementEventSources",
        "data_resources": "DataResources",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    include_management_events: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    read_write_type: Optional[Union[str, ReadWriteType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    exclude_management_event_sources: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_resources: Optional[list[DataResource]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class InsightSelector:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "insight_type": "InsightType",
        "event_categories": "EventCategories",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    insight_type: Optional[Union[str, InsightType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    event_categories: Optional[Union[list[str], Ref]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class Trail(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cloud"""

    resource_type: ClassVar[str] = "AWS::CloudTrail::Trail"
    _property_mappings: ClassVar[dict[str, str]] = {
        "include_global_service_events": "IncludeGlobalServiceEvents",
        "event_selectors": "EventSelectors",
        "kms_key_id": "KMSKeyId",
        "aggregation_configurations": "AggregationConfigurations",
        "cloud_watch_logs_role_arn": "CloudWatchLogsRoleArn",
        "s3_key_prefix": "S3KeyPrefix",
        "advanced_event_selectors": "AdvancedEventSelectors",
        "trail_name": "TrailName",
        "is_organization_trail": "IsOrganizationTrail",
        "insight_selectors": "InsightSelectors",
        "cloud_watch_logs_log_group_arn": "CloudWatchLogsLogGroupArn",
        "sns_topic_name": "SnsTopicName",
        "is_multi_region_trail": "IsMultiRegionTrail",
        "s3_bucket_name": "S3BucketName",
        "enable_log_file_validation": "EnableLogFileValidation",
        "tags": "Tags",
        "is_logging": "IsLogging",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    include_global_service_events: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    event_selectors: Optional[list[EventSelector]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    aggregation_configurations: Optional[list[AggregationConfiguration]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cloud_watch_logs_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    s3_key_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    advanced_event_selectors: Optional[list[AdvancedEventSelector]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    trail_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    is_organization_trail: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    insight_selectors: Optional[list[InsightSelector]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cloud_watch_logs_log_group_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    sns_topic_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    is_multi_region_trail: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    s3_bucket_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enable_log_file_validation: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    is_logging: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    @property
    def attr_sns_topic_arn(self) -> GetAtt:
        """Get the SnsTopicArn attribute."""
        return self.get_att("SnsTopicArn")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




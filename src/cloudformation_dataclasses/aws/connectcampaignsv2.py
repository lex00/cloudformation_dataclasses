"""
AWS CloudFormation ConnectCampaignsV2 Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 21:37:37

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service ConnectCampaignsV2
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class AgentAction:
    """AgentAction enum values."""

    DISCARD = "DISCARD"


class CampaignDeletionPolicy:
    """CampaignDeletionPolicy enum values."""

    RETAIN_ALL = "RETAIN_ALL"
    DELETE_ALL = "DELETE_ALL"


class CampaignState:
    """CampaignState enum values."""

    INITIALIZED = "Initialized"
    RUNNING = "Running"
    PAUSED = "Paused"
    STOPPED = "Stopped"
    FAILED = "Failed"
    COMPLETED = "Completed"


class ChannelSubtype:
    """ChannelSubtype enum values."""

    TELEPHONY = "TELEPHONY"
    SMS = "SMS"
    EMAIL = "EMAIL"
    WHATSAPP = "WHATSAPP"


class CommunicationLimitTimeUnit:
    """CommunicationLimitTimeUnit enum values."""

    DAY = "DAY"


class CommunicationLimitsConfigType:
    """CommunicationLimitsConfigType enum values."""

    ALL_CHANNEL_SUBTYPES = "ALL_CHANNEL_SUBTYPES"


class CommunicationTimeConfigType:
    """CommunicationTimeConfigType enum values."""

    TELEPHONY = "TELEPHONY"
    SMS = "SMS"
    EMAIL = "EMAIL"
    WHATSAPP = "WHATSAPP"


class DayOfWeek:
    """DayOfWeek enum values."""

    MONDAY = "MONDAY"
    TUESDAY = "TUESDAY"
    WEDNESDAY = "WEDNESDAY"
    THURSDAY = "THURSDAY"
    FRIDAY = "FRIDAY"
    SATURDAY = "SATURDAY"
    SUNDAY = "SUNDAY"


class EncryptionType:
    """EncryptionType enum values."""

    KMS = "KMS"


class EventType:
    """EventType enum values."""

    CAMPAIGN_EMAIL = "Campaign-Email"
    CAMPAIGN_SMS = "Campaign-SMS"
    CAMPAIGN_TELEPHONY = "Campaign-Telephony"
    CAMPAIGN_ORCHESTRATION = "Campaign-Orchestration"


class ExternalCampaignType:
    """ExternalCampaignType enum values."""

    MANAGED = "MANAGED"
    JOURNEY = "JOURNEY"


class FailureCode:
    """FailureCode enum values."""

    INVALIDINPUT = "InvalidInput"
    REQUESTTHROTTLED = "RequestThrottled"
    UNKNOWNERROR = "UnknownError"
    BUFFERLIMITEXCEEDED = "BufferLimitExceeded"


class GetCampaignStateBatchFailureCode:
    """GetCampaignStateBatchFailureCode enum values."""

    RESOURCENOTFOUND = "ResourceNotFound"
    UNKNOWNERROR = "UnknownError"


class InstanceIdFilterOperator:
    """InstanceIdFilterOperator enum values."""

    EQ = "Eq"


class InstanceLimitsHandling:
    """InstanceLimitsHandling enum values."""

    OPT_IN = "OPT_IN"
    OPT_OUT = "OPT_OUT"


class InstanceOnboardingJobFailureCode:
    """InstanceOnboardingJobFailureCode enum values."""

    EVENT_BRIDGE_ACCESS_DENIED = "EVENT_BRIDGE_ACCESS_DENIED"
    EVENT_BRIDGE_MANAGED_RULE_LIMIT_EXCEEDED = "EVENT_BRIDGE_MANAGED_RULE_LIMIT_EXCEEDED"
    IAM_ACCESS_DENIED = "IAM_ACCESS_DENIED"
    KMS_ACCESS_DENIED = "KMS_ACCESS_DENIED"
    KMS_KEY_NOT_FOUND = "KMS_KEY_NOT_FOUND"
    INTERNAL_FAILURE = "INTERNAL_FAILURE"


class InstanceOnboardingJobStatusCode:
    """InstanceOnboardingJobStatusCode enum values."""

    IN_PROGRESS = "IN_PROGRESS"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"


class LocalTimeZoneDetectionType:
    """LocalTimeZoneDetectionType enum values."""

    ZIP_CODE = "ZIP_CODE"
    AREA_CODE = "AREA_CODE"


class ProfileOutboundRequestFailureCode:
    """ProfileOutboundRequestFailureCode enum values."""

    UNKNOWNERROR = "UnknownError"
    RESOURCENOTFOUND = "ResourceNotFound"
    CONFLICT = "Conflict"
    REQUESTTHROTTLED = "RequestThrottled"
    INVALIDINPUT = "InvalidInput"


# Convenient aliases for enum values
DISCARD = AgentAction.DISCARD
RETAIN_ALL = CampaignDeletionPolicy.RETAIN_ALL
DELETE_ALL = CampaignDeletionPolicy.DELETE_ALL
INITIALIZED = CampaignState.INITIALIZED
RUNNING = CampaignState.RUNNING
PAUSED = CampaignState.PAUSED
STOPPED = CampaignState.STOPPED
FAILED = CampaignState.FAILED
COMPLETED = CampaignState.COMPLETED
TELEPHONY = ChannelSubtype.TELEPHONY
SMS = ChannelSubtype.SMS
EMAIL = ChannelSubtype.EMAIL
WHATSAPP = ChannelSubtype.WHATSAPP
DAY = CommunicationLimitTimeUnit.DAY
ALL_CHANNEL_SUBTYPES = CommunicationLimitsConfigType.ALL_CHANNEL_SUBTYPES
TELEPHONY = CommunicationTimeConfigType.TELEPHONY
SMS = CommunicationTimeConfigType.SMS
EMAIL = CommunicationTimeConfigType.EMAIL
WHATSAPP = CommunicationTimeConfigType.WHATSAPP
MONDAY = DayOfWeek.MONDAY
TUESDAY = DayOfWeek.TUESDAY
WEDNESDAY = DayOfWeek.WEDNESDAY
THURSDAY = DayOfWeek.THURSDAY
FRIDAY = DayOfWeek.FRIDAY
SATURDAY = DayOfWeek.SATURDAY
SUNDAY = DayOfWeek.SUNDAY
KMS = EncryptionType.KMS
CAMPAIGN_EMAIL = EventType.CAMPAIGN_EMAIL
CAMPAIGN_SMS = EventType.CAMPAIGN_SMS
CAMPAIGN_TELEPHONY = EventType.CAMPAIGN_TELEPHONY
CAMPAIGN_ORCHESTRATION = EventType.CAMPAIGN_ORCHESTRATION
MANAGED = ExternalCampaignType.MANAGED
JOURNEY = ExternalCampaignType.JOURNEY
INVALIDINPUT = FailureCode.INVALIDINPUT
REQUESTTHROTTLED = FailureCode.REQUESTTHROTTLED
UNKNOWNERROR = FailureCode.UNKNOWNERROR
BUFFERLIMITEXCEEDED = FailureCode.BUFFERLIMITEXCEEDED
RESOURCENOTFOUND = GetCampaignStateBatchFailureCode.RESOURCENOTFOUND
UNKNOWNERROR = GetCampaignStateBatchFailureCode.UNKNOWNERROR
EQ = InstanceIdFilterOperator.EQ
OPT_IN = InstanceLimitsHandling.OPT_IN
OPT_OUT = InstanceLimitsHandling.OPT_OUT
EVENT_BRIDGE_ACCESS_DENIED = InstanceOnboardingJobFailureCode.EVENT_BRIDGE_ACCESS_DENIED
EVENT_BRIDGE_MANAGED_RULE_LIMIT_EXCEEDED = InstanceOnboardingJobFailureCode.EVENT_BRIDGE_MANAGED_RULE_LIMIT_EXCEEDED
IAM_ACCESS_DENIED = InstanceOnboardingJobFailureCode.IAM_ACCESS_DENIED
KMS_ACCESS_DENIED = InstanceOnboardingJobFailureCode.KMS_ACCESS_DENIED
KMS_KEY_NOT_FOUND = InstanceOnboardingJobFailureCode.KMS_KEY_NOT_FOUND
INTERNAL_FAILURE = InstanceOnboardingJobFailureCode.INTERNAL_FAILURE
IN_PROGRESS = InstanceOnboardingJobStatusCode.IN_PROGRESS
SUCCEEDED = InstanceOnboardingJobStatusCode.SUCCEEDED
FAILED = InstanceOnboardingJobStatusCode.FAILED
ZIP_CODE = LocalTimeZoneDetectionType.ZIP_CODE
AREA_CODE = LocalTimeZoneDetectionType.AREA_CODE
UNKNOWNERROR = ProfileOutboundRequestFailureCode.UNKNOWNERROR
RESOURCENOTFOUND = ProfileOutboundRequestFailureCode.RESOURCENOTFOUND
CONFLICT = ProfileOutboundRequestFailureCode.CONFLICT
REQUESTTHROTTLED = ProfileOutboundRequestFailureCode.REQUESTTHROTTLED
INVALIDINPUT = ProfileOutboundRequestFailureCode.INVALIDINPUT


@dataclass
class AnswerMachineDetectionConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "enable_answer_machine_detection": "EnableAnswerMachineDetection",
        "await_answer_machine_prompt": "AwaitAnswerMachinePrompt",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_answer_machine_detection: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    await_answer_machine_prompt: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class ChannelSubtypeConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "email": "Email",
        "telephony": "Telephony",
        "sms": "Sms",
        "whats_app": "WhatsApp",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    email: Optional[EmailChannelSubtypeConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    telephony: Optional[TelephonyChannelSubtypeConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    sms: Optional[SmsChannelSubtypeConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    whats_app: Optional[WhatsAppChannelSubtypeConfig] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class CommunicationLimit:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "frequency": "Frequency",
        "max_count_per_recipient": "MaxCountPerRecipient",
        "unit": "Unit",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    frequency: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_count_per_recipient: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    unit: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class CommunicationLimits:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "communication_limit_list": "CommunicationLimitList",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    communication_limit_list: Optional[list[CommunicationLimit]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class CommunicationLimitsConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "all_channels_subtypes": "AllChannelsSubtypes",
        "instance_limits_handling": "InstanceLimitsHandling",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    all_channels_subtypes: Optional[CommunicationLimits] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_limits_handling: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class CommunicationTimeConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "local_time_zone_config": "LocalTimeZoneConfig",
        "email": "Email",
        "telephony": "Telephony",
        "sms": "Sms",
        "whats_app": "WhatsApp",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_time_zone_config: Optional[LocalTimeZoneConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    email: Optional[TimeWindow] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    telephony: Optional[TimeWindow] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    sms: Optional[TimeWindow] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    whats_app: Optional[TimeWindow] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class DailyHour:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "value": "Value",
        "key": "Key",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[list[TimeRange]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class EmailChannelSubtypeConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "outbound_mode": "OutboundMode",
        "capacity": "Capacity",
        "default_outbound_config": "DefaultOutboundConfig",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    outbound_mode: Optional[EmailOutboundMode] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_outbound_config: Optional[EmailOutboundConfig] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class EmailOutboundConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "connect_source_email_address": "ConnectSourceEmailAddress",
        "source_email_address_display_name": "SourceEmailAddressDisplayName",
        "wisdom_template_arn": "WisdomTemplateArn",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    connect_source_email_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_email_address_display_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    wisdom_template_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class EmailOutboundMode:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "agentless_config": "AgentlessConfig",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    agentless_config: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class EventTrigger:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "customer_profiles_domain_arn": "CustomerProfilesDomainArn",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    customer_profiles_domain_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class LocalTimeZoneConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "default_time_zone": "DefaultTimeZone",
        "local_time_zone_detection": "LocalTimeZoneDetection",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_time_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_time_zone_detection: Optional[Union[list[str], Ref]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class OpenHours:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "daily_hours": "DailyHours",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    daily_hours: Optional[list[DailyHour]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class PredictiveConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "bandwidth_allocation": "BandwidthAllocation",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bandwidth_allocation: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class PreviewConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "timeout_config": "TimeoutConfig",
        "agent_actions": "AgentActions",
        "bandwidth_allocation": "BandwidthAllocation",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    timeout_config: Optional[TimeoutConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    agent_actions: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bandwidth_allocation: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class ProgressiveConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "bandwidth_allocation": "BandwidthAllocation",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bandwidth_allocation: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class RestrictedPeriod:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "start_date": "StartDate",
        "end_date": "EndDate",
        "name": "Name",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    start_date: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    end_date: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class RestrictedPeriods:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "restricted_period_list": "RestrictedPeriodList",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    restricted_period_list: Optional[list[RestrictedPeriod]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class Schedule:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "end_time": "EndTime",
        "start_time": "StartTime",
        "refresh_frequency": "RefreshFrequency",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    end_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    start_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    refresh_frequency: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class SmsChannelSubtypeConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "outbound_mode": "OutboundMode",
        "capacity": "Capacity",
        "default_outbound_config": "DefaultOutboundConfig",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    outbound_mode: Optional[SmsOutboundMode] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_outbound_config: Optional[SmsOutboundConfig] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class SmsOutboundConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "connect_source_phone_number_arn": "ConnectSourcePhoneNumberArn",
        "wisdom_template_arn": "WisdomTemplateArn",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    connect_source_phone_number_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    wisdom_template_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class SmsOutboundMode:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "agentless_config": "AgentlessConfig",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    agentless_config: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class Source:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "customer_profiles_segment_arn": "CustomerProfilesSegmentArn",
        "event_trigger": "EventTrigger",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    customer_profiles_segment_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    event_trigger: Optional[EventTrigger] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TelephonyChannelSubtypeConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "outbound_mode": "OutboundMode",
        "capacity": "Capacity",
        "connect_queue_id": "ConnectQueueId",
        "default_outbound_config": "DefaultOutboundConfig",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    outbound_mode: Optional[TelephonyOutboundMode] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    connect_queue_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_outbound_config: Optional[TelephonyOutboundConfig] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TelephonyOutboundConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "connect_contact_flow_id": "ConnectContactFlowId",
        "ring_timeout": "RingTimeout",
        "answer_machine_detection_config": "AnswerMachineDetectionConfig",
        "connect_source_phone_number": "ConnectSourcePhoneNumber",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    connect_contact_flow_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ring_timeout: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    answer_machine_detection_config: Optional[AnswerMachineDetectionConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    connect_source_phone_number: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TelephonyOutboundMode:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "progressive_config": "ProgressiveConfig",
        "predictive_config": "PredictiveConfig",
        "agentless_config": "AgentlessConfig",
        "preview_config": "PreviewConfig",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    progressive_config: Optional[ProgressiveConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    predictive_config: Optional[PredictiveConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    agentless_config: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    preview_config: Optional[PreviewConfig] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TimeRange:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "end_time": "EndTime",
        "start_time": "StartTime",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    end_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    start_time: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TimeWindow:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "open_hours": "OpenHours",
        "restricted_periods": "RestrictedPeriods",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    open_hours: Optional[OpenHours] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    restricted_periods: Optional[RestrictedPeriods] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class TimeoutConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "duration_in_seconds": "DurationInSeconds",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    duration_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class WhatsAppChannelSubtypeConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "outbound_mode": "OutboundMode",
        "capacity": "Capacity",
        "default_outbound_config": "DefaultOutboundConfig",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    outbound_mode: Optional[WhatsAppOutboundMode] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_outbound_config: Optional[WhatsAppOutboundConfig] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class WhatsAppOutboundConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "connect_source_phone_number_arn": "ConnectSourcePhoneNumberArn",
        "wisdom_template_arn": "WisdomTemplateArn",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    connect_source_phone_number_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    wisdom_template_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class WhatsAppOutboundMode:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    _property_mappings: ClassVar[dict[str, str]] = {
        "agentless_config": "AgentlessConfig",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    agentless_config: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None

    def _serialize_value(self, value: Any) -> Any:
        """Recursively serialize a value."""
        if hasattr(value, 'to_dict'):
            return value.to_dict()
        if isinstance(value, list):
            return [self._serialize_value(item) for item in value]
        if isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        return value

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}
        for field_name, cf_name in self._property_mappings.items():
            value = getattr(self, field_name, None)
            if value is not None:
                props[cf_name] = self._serialize_value(value)
        return props


@dataclass
class Campaign(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-conne"""

    resource_type: ClassVar[str] = "AWS::ConnectCampaignsV2::Campaign"
    _property_mappings: ClassVar[dict[str, str]] = {
        "communication_limits_override": "CommunicationLimitsOverride",
        "type_": "Type",
        "channel_subtype_config": "ChannelSubtypeConfig",
        "connect_campaign_flow_arn": "ConnectCampaignFlowArn",
        "schedule": "Schedule",
        "communication_time_config": "CommunicationTimeConfig",
        "connect_instance_id": "ConnectInstanceId",
        "source": "Source",
        "tags": "Tags",
        "name": "Name",
    }

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    communication_limits_override: Optional[CommunicationLimitsConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    channel_subtype_config: Optional[ChannelSubtypeConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    connect_campaign_flow_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    schedule: Optional[Schedule] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    communication_time_config: Optional[CommunicationTimeConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    connect_instance_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source: Optional[Source] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




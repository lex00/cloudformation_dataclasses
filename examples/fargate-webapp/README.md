# Fargate Webapp Multi-Stack Example

> **Note:** This entire example was generated by Claude Code (claude-opus-4-5-20251101) from a single prompt. The agent created all 5 stacks, the orchestration scripts, this README, and the test suite autonomously.

## How This Example Was Created

This example was generated using the following prompt:

```
I want to plan a complex example that deploys

 - A VPC with private subnets
 - An ALB with ACM cert for demo domain + ECR 
 - An RDS database
 - A Fargate web service ( nginx helloworld )

each of the above 4 items will be packaged in a separate package created by cloudformation-dataclasses init.  Each should have the outputs required to feed the others.  They depend on eachother in order starting with the VPC.

Finally there will be some orchestration that will stage each template to S3 and create them.  This code could be bash or python.  It needs to take the outputs from VPC and use them as inputs to create the ALB package, and so on for each.
```

From this prompt, Claude Code:
1. Asked questions and added the DNS element, then designed the architecture with 5 independent stacks
2. Created the directory structure and initialized each package
3. Implemented all CloudFormation resources using `cloudformation_dataclasses`
4. Wrote bash orchestration scripts for deployment and teardown
5. Created comprehensive tests (19 test cases)
6. Wrote this documentation

---

A production-like Fargate web application spanning 5 independent CloudFormation stacks, demonstrating cross-stack orchestration with `cloudformation_dataclasses`.

## Architecture

```
                         fargate-webapp/
+---------------------------------------------------------------------+
|                                                                     |
|  +----------+    +----------+    +----------+    +--------------+   |
|  |   vpc    |--->|   dns    |--->|   alb    |--->|   fargate    |   |
|  +----------+    +----------+    +----------+    +--------------+   |
|       |                               ^               ^             |
|       |                               |               |             |
|       +---------------+---------------+---------------+             |
|                       |                                             |
|                  +----------+                                       |
|                  |   rds    |                                       |
|                  +----------+                                       |
|                                                                     |
|  +---------------------------------------------------------------+  |
|  |  deploy.sh / teardown.sh (bash orchestration)                 |  |
|  +---------------------------------------------------------------+  |
+---------------------------------------------------------------------+
```

## Stack Details

### 1. vpc/ - Network Foundation
- VPC (10.0.0.0/16)
- 3 public subnets (10.0.1.0/24, 10.0.2.0/24, 10.0.3.0/24)
- 3 private subnets (10.0.11.0/24, 10.0.12.0/24, 10.0.13.0/24)
- Internet Gateway
- 3 NAT Gateways (one per AZ)
- Route tables

**Outputs:** VpcId, PublicSubnetIds, PrivateSubnetIds

### 2. dns/ - Domain & Certificate
- Route53 Hosted Zone
- ACM Certificate (with DNS validation)

**Parameters:** DomainName
**Outputs:** HostedZoneId, CertificateArn, NameServers

### 3. alb/ - Application Load Balancer
- Application Load Balancer
- ALB Security Group (80, 443 from anywhere)
- HTTP Listener (redirect to HTTPS)
- HTTPS Listener (with ACM cert)
- Default Target Group
- Route53 A record (alias to ALB)

**Parameters:** VpcId, PublicSubnetIds, CertificateArn, HostedZoneId, DomainName
**Outputs:** AlbArn, AlbDnsName, AlbSecurityGroupId, TargetGroupArn, HttpsListenerArn

### 4. rds/ - PostgreSQL Database
- RDS Subnet Group
- RDS Security Group (5432 from VPC CIDR)
- RDS PostgreSQL Instance (db.t3.micro)
- Secrets Manager secret (master password)

**Parameters:** VpcId, PrivateSubnetIds, VpcCidr, DatabaseName
**Outputs:** DbEndpoint, DbPort, DbSecretArn, DbSecurityGroupId

### 5. fargate/ - Web Service
- ECS Cluster
- ECS Task Definition (nginx:alpine)
- ECS Service (Fargate, 2 tasks)
- Task Security Group (from ALB only)
- IAM Task Role
- IAM Task Execution Role
- CloudWatch Log Group

**Parameters:** VpcId, PrivateSubnetIds, AlbSecurityGroupId, TargetGroupArn, DbEndpoint, DbSecretArn
**Outputs:** ClusterArn, ServiceName, ServiceArn

## Prerequisites

1. AWS CLI configured with appropriate credentials
2. Python 3.10+
3. An S3 bucket for template storage
4. A domain name you own (for Route53 and ACM)

## Deployment

1. Clone the repository and install dependencies:

```bash
cd examples/fargate-webapp
```

2. Deploy all stacks:

```bash
./deploy.sh example.com my-template-bucket
```

The script will:
- Deploy the VPC stack
- Deploy the DNS stack and prompt you to update nameservers at your registrar
- Wait for ACM certificate validation
- Deploy the ALB, RDS, and Fargate stacks

3. After DNS propagation, your service will be available at `https://example.com`

## Teardown

To delete all stacks in reverse order:

```bash
./teardown.sh
```

## Cost Estimate

| Resource | Approximate Monthly Cost |
|----------|-------------------------|
| NAT Gateways (3) | ~$96 |
| ALB | ~$16 |
| RDS db.t3.micro | ~$15 |
| Fargate (2 tasks) | ~$20 |
| Route53 Hosted Zone | ~$0.50 |
| **Total** | **~$150/month** |

**Warning:** Running this example will incur AWS charges. Remember to run `./teardown.sh` when you're done.

## Testing Templates Locally

You can generate and validate individual stack templates:

```bash
# Generate VPC template
cd vpc && python -m vpc | python -m json.tool

# Generate DNS template
cd dns && python -m dns | python -m json.tool

# Generate ALB template
cd alb && python -m alb | python -m json.tool

# Generate RDS template
cd rds && python -m rds | python -m json.tool

# Generate Fargate template
cd fargate && python -m fargate | python -m json.tool
```

## Design Decisions

- **No Fn::ImportValue**: The orchestrator explicitly passes outputs as parameters. This is more verbose but makes dependencies clearer and allows stacks to be deployed independently.

- **Secrets Manager for RDS**: Best practice for credentials. Fargate can reference the secret directly.

- **3 AZs with NAT per AZ**: Production-like availability, but increases cost. For development, you could modify to use a single NAT Gateway.

- **Nginx hello world**: Simplest possible Fargate task to prove the pattern. Replace with your actual application image.

- **ACM DNS validation**: Automated via Route53 records in the dns/ stack.

## Customization

To customize this example for your application:

1. Update `fargate/fargate/stack/fargate.py`:
   - Change the container image from `nginx:alpine` to your application
   - Adjust CPU/memory as needed
   - Add environment variables for your app

2. Modify security groups if your app needs different ports

3. Add additional resources (e.g., ElastiCache, S3 buckets) as new stacks

4. Update IAM roles in `TaskRole` with permissions your application needs
